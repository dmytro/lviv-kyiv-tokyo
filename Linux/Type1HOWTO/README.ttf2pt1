TTF2PT1 - A true type to Postscript type 1 Converter 

[
 Based on ttf2pfa by Andrew Weeks, and help from Frank Siegert.
 Modification by Mark Heath.
 Further modification by Sergey Babkin.
 The Type1 assembler by I. Lee Hetherington with modifications by 
 Kai-Uwe Herbing.
]


Ever wanted to install a particular font on your XServer but only could find 
the font you are after in True Type Format?

Ever Asked comp.fonts for a True Type to Type 1 converter and got a List 
of Commercial software that doesn't run on your Operating System?

Well This program should be the answer.  This program is written in C (so it
should be portable)  and therefore should run on any OS.  The only limitation
is that the program requires some method of converting Big endian integers into
local host integers so the network functions ntohs and ntohl are used. These 
can be replaced by macros if your platform doesn't have them. 
Of course the target platform requires a C compiler and command line ability.

The version 3.0 got rather extensive post-processing algorithm that brings
the converted fonts to the requirements of the Type1 standard, tries to
correct the rounding errors introduced during conversions and some simple
kinds of bugs that are typical for the public domain TTF fonts. It
also generates the hints that enable much better rendering of fonts in
small sizes that are typical for the computer displays. But everything
has its price, and some of the optimizations may not work well for certain
fonts. That's why the options were added to the converter, to control
the performed optimizations.

The converter is simple to run, just:

	ttf2pt1 [-options] ttffont.ttf Fontname
or
	ttf2pt1 [-options] ttffont.ttf -

The first variant creates the file Fontname.pfa with the converted font,
the second one prints the font on the standard output from where it can
be immediately piped through some filter.

Most of the time no options are neccessary (with a possible exception
of `-e'). But if there are some troubles with the resulting font, they 
may be used to control the conversion.
The options are:

-e - Encode the resulting font to produce a ready .pfa file.
   [S.B.: Personally I don't think that this option is especially useful.
   The same result may be achieved by piping the unencoded data
   through t1asm, the Type 1 assembler. And, anyways, it's good to
   have the t1utils package handy. But Mark thinks that this functionality
   is good and it took not much time to add this option.]
-o - Disable the optimization of the outlines' code. This kind of optimization
   never hurts, and the only usage of this option is for comparison of the
   generated fonts with the fonts generated by the previous versions of 
   converter.
-s - Disable the smoothing of outlines. If the font is broken in some
   way (even the ones that are not easily noticeable), such smoothing 
   may break it further. So this option is the first thing to be tried
   if some font looks odd. But with smoothing off the hint generation
   algorithms may not work properly too.
-t - Disable auto-scaling to the 1000x1000 Type1 standard matrix. The
   TTF fonts are described in terms of an arbitrary matrix up to
   4000x4000. The converted fonts must be scaled to conform to
   the Type1 standard. But the scaling introduces additional rounding
   errors, so it may be curious sometimes to look at the font in its
   original scale.
-h - Disable the autogeneration of hints. The really complex outlines
   may confuse the algorithm, so theoretically it may be useful
   sometimes to disable them. Although up to now it seems that
   even bad hints are better than no hints at all.
-f - Don't try to force the fixed width of font. Normally the converter
   considers the fonts in which the glyph width deviates by not more
   than 5% as buggy fixed width fonts and forces them to have really
   fixed width. If this is undesirable, it can be disabled by this option.
-a - Prints out the absolute coordinates of dots in outlines. Such
   a font can not be used by any program (that's why this option is
   incompatible with `-e') but it has proven to be a valuable debuging 
   information.
-r - Do not reverse the direction of outlines. The TTF fonts have
   the standard direction of outlines opposite to the Type1 fonts. So
   they should be reversed during proper conversion. This option
   may be used for debugging or to handle a TTF font with wrong
   direction of outlines (possibly, converted in a broken way from
   a Type1 font). The first signs of the wrong direction are the
   letters like "P" or "B" without the unpainted "holes" inside.

The .pfa font format supposes that the description of the characters
is binary encoded and encrypted. This converter does not encode or
encrypt the data by default, you have to specify the option `-e'
or use the `t1utils' package to assemble (that means, encode and
encrypt) the font program. It may be obtained from

	http://quadrant.netspace.net.au/~mark/ttf2pt1/

as well as this converter itself. So, the following command lines:

	ttf2pt1 -e ttffont.ttf t1font
	ttf2pt1 ttffont.ttf - | t1asm >t1font.pfa

represent two ways to get a working font. The benefit of the second form 
is that other filters may be applied to the font between the converter
and assembler.

But running the converter manually becomes somewhat boring if it has to 
be applied to a few hundreds of fonts and then you have to generate the 
fonts.scale and/or Fontmap files. The INSTALL file describes how to use 
the supplied scripts to handle such cases easily. The installation
scripts use the `t1utils' package and won't work without it.

Another small and interesting program and its README file is
located in the `others' subdirectory.

TODO:
-----
- Improve hinting. Implement the hints substitution.
- Implement the family-level hints.
- Handle the composite glyphs with relative base points.
- Preserve the relative width of stems during scaling to 1000x1000 matrix.
- Generate the font metrics.
- Write the man pages.

SEE ALSO
--------

http://fonts.apple.com/TTRefMan/index.html
  The True Type reference manual.

http://www.adobe.com/supportservice/devrelations/PDFS/TN/T1_SPEC.PDF
  The specification of the Type 1 font format.

http://www.adobe.com/supportservice/devrelations/PDFS/TN/5004.AFM_Spec.pdf
  The specification of the Adobe font metrics file format.

http://www.cs.wpi.edu/~matt/courses/cs563/talks/surface/bez_surf.html
http://www.cs.wpi.edu/~matt/courses/cs563/talks/curves.html
  Information about the Bezier curves.


Copyright issues
----------------

Note please that the t1asm.c file (and the compiled ttf2pt1 program that
includes the code produced from it) and the installation scripts are 
under a BSD-style license, while the converter itself is under the public 
domain license. 

Following is the Readme of ttf2pfa (true type to type 3 font converter) It 
covers other issues regarding the use of this software.

True Type to Postscript Font converter
--------------------------------------

My mind is still reeling from the discovery that I was able to write
this program. What it does is it reads a Microsoft TrueType font and
creates a Postscript font. '_A_ postscript font', that is, not necessarily
the same font, you understand, but a fair imitation.

Run it like this:

	ttf2pfa fontfile.ttf fontname

The first parameter is the truetype filename, the second is a stem for
the output file names. The program will create a fontname.pfa containing
the Postscript font and a fontname.afm containing the metrics.

The motivation behind this is that in Linux if you do not have a
Postscript printer, but only some other printer, you can only print
Postscript by using Ghostscript. But the fonts that come with
Ghostscript are very poor (they are converted from bitmaps and look
rather lumpy). This is rather frustrating as the PC running Linux
probably has MS-Windows as well and will therefore have truetype fonts,
but which are quite useless with Linux, X or Ghostscript.

The program has been tested on over a hundred different TrueType fonts
from various sources, and seems to work fairly well. The converted
characters look OK, and the program doesn't seem to crash any more. I'm
not sure about the AFM files though, as I have no means to test them.

The fonts generated will not work with X, as the font rasterizer that
comes with X only copes with Type 1 fonts. If I have the time I may
modify ttf2pfa to generate Type 1s.

Copyright issues
----------------

I am putting this program into the public domain, so don't bother
sending me any money, I'd only have to declare it for income tax.

Copyright on fonts, however, is a difficult legal question. Any
copyright statements found in a font will be preserved in the output.
Whether you are entitled to translate them at all I don't know.

If you have a license to run a software package, like say MS-Windows, on
your PC, then you probably have a right to use any part of it, including
fonts, on that PC, even if not using that package for its intended
purpose.

I am not a lawyer, however, so this is not a legal opinion, and may be
garbage.

There shouldn't be a any problem with public domain fonts.

About the Program
-----------------

It was written in C on a IBM PC running Linux.

The TrueType format was originally developed by Apple for the MAC, which
has opposite endianness to the PC, so to ensure compatibility 16 and 32
bit fields are the wrong way round from the PC's point of view. This is
the reason for all the 'ntohs' and 'ntohl' calls. Doing it this way
means the program will also work on big-endian machines like Suns.

I doubt whether it will work on a DOS-based PC though.

The program produces what technically are Type 3 rather than Type 1
fonts. They are not compressed or encrypted and are plain text. This is
so I (and you) can see what's going on, and (if you're a Postscript guru
and really want to) can alter the outlines.

I only translate the outlines, not the 'instructions' that come with
them. This latter task is probably virtually impossible anyway. TrueType
outlines are B-splines rather than the Bezier curves that Postscript
uses. I believe that my conversion algorithm is reasonably correct, if
nothing else because the characters look right.

Problems that may occur
-----------------------

Most seriously, very complex characters (with lots of outline segments)
can make Ghostscript releases 2.x.x fail with a 'limitcheck' error. It
is possible that this may happen with some older Postscript printers as
well. Such characters will be flagged by the program and there are
basically two things you can do. First is to edit the .pfa file to
simplify or remove the offending character. This is not really
recommended. The second is to use Ghostscript release 3, if you can get
it. This has much larger limits and does not seem to have any problems
with complex characters.

Then there are buggy fonts (yes, a font can have bugs). I try to deal
with these in as sane a manner as possible, but it's not always
possible.

Encodings
---------

A postscript font must have a 256 element array, called an encoding,
each element of which is a name, which is also the name of a procedure
contained within the font. The 'BuildChar' command takes a byte and uses
it to index the encoding array to find a character name, and then looks
that up in the font's procedure table find the commands to draw the
glyph. However, not all characters need be in the encoding array. Those
that are not cannot be drawn (at least not using 'show'), however it is
possible to 're-encode' the font to enable these characters. There are
several standard encodings: Adobe's original, ISO-Latin1 and Symbol
being the most commonly encountered.

TrueType fonts are organised differently. As well as the glyph
descriptions there are a number of tables. One of these is a mapping
from a character set into the glyph array, and another is a mapping from
the glyph array into a set of Postscript character names. The problems
are:
	1)	Microsoft uses Unicode, a 16-bit system, to encode the font.
	2)	that more than one glyph is given the same Postscript name.

I deal with (1) by assuming a Latin1 encoding. The MS-Windows and
Unicode character sets are both supersets of ISO-8859-1. This usually
means that most characters will be properly encoded, but you should be
warned that some software may assume that fonts have an Adobe encoding.
Symbol, or Dingbat, fonts are in fact less of a problem, as they have
private encodings starting at 0xF000. It is easy to just lose the top
byte.

Postscript fonts can be re-encoded, either manually, or by software.
Groff, for example, generates postscript that re-encodes fonts with the
Adobe encoding. The problem here is that not all characters in the Adobe
set are in the MS-Windows set. In particular there are no fi and fl
ligatures. This means that conversions of the versions of
Times-New-Roman and Arial that come with MS-Windows cannot be used
blindly as replacements for Adobe Times-Roman and Helvetica. You can get
expanded versions of MS fonts from Microsoft's web site which do contain
these ligatures (and a lot else besides).

I deal with (2) by creating new character names. This can be error-prone
because I do not know which of them is the correct glyph to give the
name to. Some (buggy) fonts have large numbers of blank glyphs, all with
the same name.

(almost every TrueType font has three glyphs called .notdef, one of them
is usually an empty square shape, one has no outline and has zero width,
and one has no outline and a positive width. This example is not really
a problem with well formed fonts since the .notdef characters are only
used for unprintable characters, which shouldn't occur in your documents
anyway).
