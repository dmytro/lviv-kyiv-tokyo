    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
    <HTML>
    <HEAD>
    <TITLE> Perl for non programmers </TITLE>
    <META NAME="generator" CONTENT="txt2html v1.25">
    </HEAD>
    <BODY>

<H1><A NAME="section-1">Перл для непрограм╕ст╕в</A></H1>
<PRE>
        <author> Дмитро Ковальов </author>
</PRE>
<H2><A NAME="section-1.1">Виконання програми, написано╖ в Перл╕.</A></H2>

<H3><A NAME="section-1.1.1">Про пошуки перл╕в в систем╕</A></H3>

<P>
Б╕льш╕сть того, що можна написати про Перл, буде справедливим для
будь-яко╖ (або хоча б для б╕льшост╕) систем, в яких Перл працю╓. Але
те, як виконувати програми написан╕ на Перл╕, у б╕льшост╕ випадк╕в
буде  специф╕чним для т╕╓╖, або ╕ншо╖ системи. 

<P>
Я маю досв╕д роботи з двома верс╕ями (напрямками) Перлу. а саме - Перл
для Юн╕кса (власне, ори╜╕нальний Перл) ╕ Перл для Мак╕нтоша
(MacPerl). MacPerl ╓ дещо специф╕чним ╕ взагал╕ заслугову╓ на окремий
розгляд, а ╕нш╕ верс╕╖ Перла (так╕, як MS-DOS, Windows тощо) мене
особисто не ц╕кавлять.

<P>
Тому, вважаючи на написане в попередньому абзац╕, надал╕ мова йтиме
т╕льки про використання Перлу в т╕й або ╕нш╕й верс╕╖ Юн╕ксу, або його
пох╕дних (таких, як наприклад Л╕накс).

<P>
Тож, перш, н╕ж намагатися виконувати програму в Перл╕, було б непагано
для початку впевнитися, що в╕н встановлений в дан╕й систем╕. В цьому 
допоможе команда 'which'. Якщо з вашою системою (а б╕льше нав╕ть не з
системою, а з середовищем користувача) все в порядку, то ви побачите
на екран╕ щось под╕бне до наступного:


<PRE>
       dk@sophy $ which perl
       /usr/bin/perl
       dk@sophy $ 
</PRE>


<P>
В трьох приведених рядках частина написана л╕воруч в╕д знаку долара:
'dk@sophy $' ╓ системним запрошенням, або як його ╕нколи
називають системою п╕дказкою ╕ може бути (напевне буде) в╕дм╕нним, в╕д
того, що ви побачите на сво╓му екран╕. Другий рядок ╓ результатом
роботи команди 'which', ╕ ╓ маршрутом (дор╕жкою) до програми 'perl'. 

<P>
Якщо Перл не встановлен╕й у ваш╕й систем╕, або якщо програма 'which'
не може його знайти, то в залежност╕ в╕д тих або ╕нших фактор╕в ви
можете побачити щось под╕бне до одного з наступних вар╕ант╕в:


<P>
(1)
<PRE>
        dk@sophy $ which perl
        dk@sophy $ 
</PRE>

<P>
(2)
<PRE>
        dk@sophy $ which perl
        which: no perl in (/usr/local/qt/bin:/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:)
        dk@sophy $ 
</PRE>

<P>
(3)
<PRE>
        dk@sophy $ which perl
        perl: Command not found.
        dk@sophy $ 
</PRE>


<P>
В першому вар╕ант╕ програма 'which' не знайшла прграму 'perl' ╕
вир╕шила не розстроювати користувача цим фактом ╕ тому, просто зробила
вигляд, що не чула запитання. У вар╕антах 2 ╕ 3 'which' подала зв╕ти
про результати сво╖х пошук╕в дещо р╕зн╕ за сво╓ю зм╕стовн╕стю. Але у
вс╕х трьох вар╕антах нас б╕льше всього ц╕кавить саме той сумний факт,
що програма Перл не може бути знайденою в ц╕й систем╕ ╕ наше навчання
в╕дклада╓ться на деякий час. 

<P>
Прошу читача звернути увагу на деяк╕ нюанси: я написав "не може бути
знайденою" на в╕дм╕ну в╕д набагато б╕льш категоричного "не
встановлена". Може бути так, що програма встановлена в систем╕, але не
дивлячись на це 'which' не може ╖╖ в╕дшукати. Це може бути насл╕дком
дуже багатьох причин, основною серед яких ╓ р╕зн╕ нестандартн╕
маршрути до програми. З вар╕анту 2 видно, що 'which' шука╓ протр╕бну
користувачев╕ програму в певних директор╕ях. Якщо Перл встановлено в
директор╕╖, яка не входить до "поля зору" 'which', то зрозум╕ло, що
Перл не буде знайдено. 

<P>
Допомогти в╕дшукати Перл в систем╕ можуть ╕нш╕ системн╕ засоби, так╕
як, наприклад, 'find', 'locate', 'rpm' (дв╕ останн╕ програми
характерн╕ для Л╕накса б╕льше, н╕ж для ╕нших Юн╕кс╕в, причому остання
з них ++ т╕льки для Л╕накс╕в, що базуються на RedHat под╕бн╕й систем╕
- так╕й як, сам RedHat, Caldera, Mandrake, TurboLinux, тощо).

<P>
Подальш╕ пошуки перл╕в в файлових системах залишимо у вигляд╕ вправи
для допитливого користувача. Якщо Перл в систем╕ не встановлено, то
вих╕д з ц╕╓╖ ситуац╕╖ дуже простий - його треба встановити. ╤ я дуже
радий заявити, що я зн╕маю з себе в╕дпов╕дальн╕сть за це, бо це
виходить з поля зору даного твору ╕ за допомогою в цьому випадку треба
звертатись до системних адм╕н╕стратор╕в.

<H3><A NAME="section-1.1.2">Верс╕╖ Перл╕в</A></H3>

<P>
Тож вважа╓мо, що невеличка вправа з програмкою 'which' зак╕нчилася
усп╕шно ╕ перейдем дал╕. А саме до того, як отримати трошки б╕льше
╕нформац╕╖ про св╕й Перл. 


<P>
Важливою ╕нформац╕╓ю про Перл ╓ його номер верс╕╖. В сучасному св╕т╕
╕снують дв╕ верс╕╖ Перл╕в - верс╕я 4 та верс╕я 5. Кожна з них
под╕ля╓ться на б╕льш др╕бн╕ п╕дверс╕╖ (тобто 4.036, 5.003, 5.005_05
тощо), але на ц╕ др╕бниц╕ ми не будемо звертати уваги ++ оск╕льки
основн╕ в╕дм╕нност╕ лежать в перших розрядах верс╕╖. 

<P>
Для б╕льшост╕ вправ нав╕ть в╕дм╕нн╕сть м╕ж верс╕╓ю 4 та 5 буде
несутт╓вою, але все-таки краще знати, що так╕ в╕дм╕нност╕ ╕снують. 

<P>
Щоб д╕знатися, яка верс╕я Перлу встановлена, надрукуйте таку команду в
командному рядку: "perl -v". ╤ ось що при цьому трапля╓ться:

<PRE>
           dk@sophy$ perl -v

           This is perl, version 5.005_02 built for i586-linux

           Copyright 1987-1998, Larry Wall

           Perl may be copied only under the terms of either the Artistic License or the
           GNU General Public License, which may be found in the Perl 5.0 source kit.

           Complete documentation for Perl, including FAQ lists, should be found on
           this system using `man perl' or `perldoc perl'.  If you have access to the
           Internet, point your browser at http://www.perl.com/, the Perl Home Page.

           dk@sophy$ 
</PRE>

<P>
Зрозум╕ло, що в першому рядку цього пов╕домлення саме ╕ вказу╓ться
верс╕я Перлу. Зрозум╕ло також, що отримавши в╕д користувача параметр
"-v", Перл не намага╓ться виконувати н╕яко╖ програми, а просто друку╓
на екран╕ номер верс╕╖ ╕ зак╕нчу╓ роботу. 

<H3><A NAME="section-1.1.3">Сама перша програма</A></H3>

<P>
Для найпрост╕шо╖ програми в Перл╕ вам не потр╕бно буде редагувати
н╕яких файл╕в, не потр╕бно комп╕лювати, в╕дладжувати, тощо. Ми створимо
╕ викона╓мо вашу першу програму прямо зараз: в той час, як ви це
чита╓те.  

<P>
По конях! До командного рядка!

<P>
 <STRONG> META </STRONG>  р╕зниця м╕ж шел ╕ редактором

<P>
Надрукуйте цю дуже просту штуку в командному рядку:
 
<PRE>
         dk@sophy$ perl -e 'print "Hello! I have written my first program! \n"'
         Hello! I have written my first program! 
         dk@sophy$ 
</PRE>

<P>
Зверн╕ть увагу на р╕зн╕ лапки (одинарн╕ та подв╕йн╕) в цьому
приклад╕. Вони важлив╕, як ╕ ╖х порядок. 

<P>
Написання програм в Перл╕ просто в командному рядку без створення
файл╕в не ╓ якимось р╕дк╕сним трюком чи звихненням або ж педагог╕чним
прийомом. ╢ багато випадк╕в, коли написати одну-дв╕ команди в Перл╕,
щоб "виловити" якусь корисну ╕нформац╕ю з файла ╓ набагато прост╕шим,
н╕ж в╕дкривати текстовий редактор ╕ записувати файл (нав╕ть якщо
текстовий редактор ╓ vi або emacs), а пот╕м виконувати цей файл. 

<P>
Давайте подивимось трохи уважн╕ше на щойно написану та виконану
програму. 

<P>
Параметр "-e" вказу╓ Перлу, що п╕сля цього йде сама власне програма, а
не назва файлу, в як╕й програма записана. Дал╕, записана в одинарних
лапках ╕де текст програми. В нашому випадку це: 

<PRE>
       print "Hello! I have written my first program! \n"
</PRE>

<P>
Одинарн╕ лапки потр╕бн╕ для того щоб ╕золювати внутр╕шн╕й текст в╕д
програмно╖ оболонки (shell), в як╕й ви працю╓те. ╤накше програмна
оболонка буде намагатися виконати команди власноручно т╕ команди, що
призначен╕ для Перла. Не у вс╕х випадках використовуються одинарн╕
лапки. Використання лапок в╕дноситься скор╕ше до в╕домства shell'а,
н╕ж до Перла. Тому, щоб зрозум╕ти краще, що в╕дбува╓ться з цими
лапками, зверн╕ться до документац╕╖ по т╕й оболонц╕, в як╕й ви
працю╓те (тобто sh, csh, tcsh, bash, ksh чи ще що-небудь). Як бачите
Юн╕кс забезпечу╓ можлив╕сть вибору в цьому в╕дношенн╕. 

<P>
Внутр╕шн╕ лапки (подв╕йн╕ в нашому випадку) в╕дносяться вже до самого
Перла. В них запису╓ться текст, який повинна вивести на екран команда
'print'. (Зрозум╕ло, що команда 'print' щось повинна друкувати -
╕накше зв╕дки би взялася ця назва? ) 

<P>
В к╕нц╕ рядка ще записана якась дивина: "\n". Ця штука завжди
використову╓ться, коли треба розбити рядок на к╕лька рядк╕в, або як
кажуть серйозн╕ люди, тобто програм╕сти: "Вставити символ к╕нця
рядка". К╕нець рядка не повинен стояти в к╕нц╕ того рядка, що ви
друку╓те. Ви його вставля╓те там де вам потр╕бно. Якщо ви трохи погра╓теся
з  вашою улюбленою програмою на Перл╕, то може бути таке:

<PRE>
        dk@sophy$ perl -e 'print "Hello! \n I\n have wri\ntt\nen my first program! \n"'
        Hello! 
         I
         have wri
        tt
        en my first program! 
        dk@sophy$
</PRE>

<H3><A NAME="section-1.1.4">Створення файлу програми</A></H3>

<P>
Для того, щоб створити найпрост╕ший файл з програмою в Перл╕ теж не
дуже багато потр╕бно. Що нам треба - це всього-навсього текстовий
редактор. (Ось зовс╕м забув, чи я казав, що для всих цих вправ
потр╕бен також комп'ютер? Якщо н╕, то потурбуйтеся про це також, поки
ще не п╕зно.)

<P>
Тож в вашому улюбленому редактор╕... Нема╓ такого? Тод╕ бер╕ть emacs,
╕ не помилитесь. Деяк╕ б╕льше люблять, звичайно  <TT>vi</TT> , але я не буду
займатися тим, щоб в╕длякувати читач╕в з самого початку. Любов до vi
приходить не зразу. Люди, як╕ користуются ним для програмування,
належать до особливого класу людей. Вони н╕коли в житт╕ не клацнуть
дв╕ч╕ мишкою на п╕ктограм╕ Microsoft Word'а. Нав╕ть до користувач╕в
emacs'у вони ставляться з деякою поблажлив╕стю, як доросла людина
робить сердитий вигляд, при вид╕ капризуючо╖ дитини, але при цьому
тихенько посм╕ю╓ться соб╕ у вуса. Користування  <TT>vi</TT>  нав╕ть ц╕лком
вр╕вноважену людину  може довести<BR>
до сл╕з. Тому наш виб╕р пада╓ на  <TT>emacs</TT> .

<H3><A NAME="section-1.1.5">Перл-режим у emacs'╕</A></H3>

<P>
Якщо ви як ╕ ми вир╕шили спинитися на emacs'╕, то наступний ваш
командний рядок буде таким:

<PRE>
          dk@sophy$ emacs myperl.pl
</PRE>

<P>
Я перейняв на себе в╕дпов╕дальн╕сть визначити назву файлу вашо╖
Перл-програми. Але зам╕сть "myperl.pl" ви можете вказати, що ваш╕й

<P>
душ╕ ближче та р╕дн╕ше.  Вибираючи назву файлу, що зак╕нчу╓ться на
"pl" (або як кажуть мастит╕ - ма╓ розширення "pl" (*) ) ви ма╓те шанс
вв╕мкнути в emacs'╕ режим Перлу. 

<P>
<hr size=1 noshade width=100 align=left><font size=-1><dl><dt><b>(*) - </b><dd>
За традиц╕╓ю MSDOS'у все, що йде п╕сля крапки в назв╕ файлу
назива╓ться розширенням, ╓дина проблема з цим у Юн╕ксах - що вони
можуть мати по к╕лька крапок в ╕мен╕ файла - отже ╕ по к╕лька
розширень). <BR>
</dl></font>

<P>
emacs ма╓ р╕зноман╕тн╕ режими для п╕дтримки (**) багатьох мов
програмування, в тому числ╕ ╕ для п╕дтримки Перл. Але я не можу
гарантувати, що цей режим вв╕мкнеться в вашому редактор╕
автоматично. emacs'и можуть в╕др╕зняти файли один в╕д одного або за
розширеннями, або ж за першим рядком файлу. Пролог (теж мова
програмування) теж користу╓ться розширенням "pl", тому деяк╕ верс╕╖
emacs'╕в можуть розп╕знати цей файл як пролог-програму ╕ вмикнути
режим Пролог зам╕сть Перл (або ж emacs може бути не настро╓ним зовс╕м
╕ не вмикнути зовс╕м н╕якого режиму). 


<P>
<hr size=1 noshade width=100 align=left><font size=-1><dl><dt><b>(**) - </b><dd>
П╕дтримка в цьому випадку означа╓ наб╕р певних засоб╕в для редагування
програм, а не власне виконання написано╖ програми. Знаючи, в як╕й мов╕
ви програму╓те, emacs зна╓ дещо про структуру ц╕╓╖ мови програмавання,
як, наприклад те, як╕ коментар╕ вона ма╓, зможе зак╕нчувати деяк╕
синтаксичн╕ структури зам╕сть вас. Якщо у ашому emacs'╕ вмикнен╕
кольоров╕ шрифти, то в╕н зможе також п╕дсв╕чувати р╕зними кольорами
синтаксис мови.<BR>
</dl></font>

<P>
Вмикнути режим Перл у вашому emacs'╕ можна так: натисн╕ть та
в╕дпуст╕ть  <TT>Esc</TT>  ╕ п╕сля цього натисн╕ть `x' (латинська л╕тера
x). П╕сля цього в самому нижньому рядку emacs'а л╕воруч з'явиться
напис `M-x'. Це запрошення emacs'а до вводу команди. Надрукуйте в
цьому рядку `perl-mode' ╕ натисн╕ть  <TT>Enter</TT> . 

<P>
Дал╕, в залежност╕ знову ж таки в╕д конф╕гурац╕╖ вашо╖ системи, а
точн╕ше вашого emacs'у, ви ма╓те два вар╕анти - або Перл-режим
вмикнеться або ж н╕. Ознакою того, що в╕н вмикнувся, буде слово
  <TT>`(Perl)'</TT> , написане в рядку статусу emacs'у (другий рядок знизу -
найчаст╕ше в╕н позаний на екран╕ в ╕нверсному кольор╕). Д╕знатися що
режим Перлу знайдено можна по пов╕домленню  <TT>No match</TT>  надрукованому в
командному рядку emacs'а. 

<P>
Якщо ви належите до т╕╓╖ категор╕╖ людей, яким не везе з встановленими
пакетами ╕ програмами, ╕ режим Перл все-таки не встановлений у ваш╕й
систем╕, зверн╕ться за допомогою до системного адм╕н╕стратора. Але не
зважаючи на невезуч╕сть ви все-одно можете продовжувати
редагувати вашу програму.

<P>
Файл програми буде складатися з одного ╓диного рядка. Тож напиш╕ть
вже знайомий вам рядок в emacs'╕:


<PRE>
         print "Hello! I have written my first program! \n"
</PRE>


<P>
╕ запиш╕ть файл. Цей рядок не ма╓ вже подв╕йних лапок, як не ма╓ ╕
самого 'perl -e'.  Виконання програми трохи в╕др╕зня╓ться в╕д
попереднього вар╕анту. В цьому випадку щоб виконати програму
поверн╕ться знову в програмну оболонку ╕ надрукуйте в командному рядку
команду: 


<PRE>
        dk@sophy$ perl mytest.pl 
        Hello! I have written my first program! 
        dk@sophy$ 
</PRE>


<P>
Як бачите з командного рядка зник параметр '-e' ╕ по цьому Перл
визнача╓, що те, що йде п╕сля слова perl ╓ назвою файлу, який треба
виконати, використовуючи ╕нтерпретатор Перл. Результат роботи
програми, як бачите, не зм╕нився.

<H3><A NAME="section-1.1.6">Дозв╕л на виконання файлу та маг╕чне число Перл-скрипту</A></H3>

<P>
Все, що писалося до цього моменту, в╕дносилося як до Юн╕кса, так ╕ до
╕нших систем, що мають командний рядок (MSDOS або MPW у Мак╕нтош╕ для
прикладу). Але на цьому схож╕сть зак╕нчу╓ться ╕ ми входимо в джунгл╕
чист╕с╕нького Юн╕ксу. Те, про що йдеться дал╕, можливо в Юн╕кс╕ ╕
т╕льки в Юн╕кс╕. Написан╕ ц╕л╕ кер╕вництва щодо того, як зробити так,
щоб в Windows NT програму, написану на Перл╕, можна було-би запускати
так, як це робиться в Юн╕кс╕.

<P>
Ми ж, не гаючи часу на дурниц,╕ переходимо зразу до справи. Чому не
можна виконувати програму так, як ми це вже робили в попередн╕й
вправ╕? Можна, але не завжди зручно. Можливо ви захочете наприклад
переписати свою стару програму (або як кажуть "скрипт") в мов╕ shell
або awk, ╕ зробити ╖╖ програмою в Перл╕. Якби не було можливо вказати,
яка програма використову╓ться для виконання того, чи ╕ншого скрипту,
то кожного разу довелося б вказувати конкретно це в командному
рядку. Тобто програма в Перл╕ завжди повинна запускатися "perl
program", скрипт в мов╕ sh завжди б запускався як "sh program". А що,
якщо я хочу написати скрипт, який би запускався просто як "program"?
Що мен╕ робити?

<P>
Спробу╓мо запустити таким чином наш скрипт. Друку╓мо:

<PRE>
        dk@sophy$ ./mytest.pl 
        ./mytest.pl: Permission denied.
        dk@sophy$ 
</PRE>

<P>
Допитливий Читач:
<PRE>
           Гм-м-м, по-перше, нащо тут крапка з косою? А по-друге що таке
           "Permission", ╕ чому воно "denied"? 
</PRE>

<P>
Автор:

<UL>
  <LI> Крапка означа╓ поточну директор╕ю (разом з косою) ╕ вказу╓
          на те, що файл який ми хочемо виконувати знаходиться ось
          тут, в ц╕й сам╕й директор╕╖, де ми ╓. А "Permission denied"
          означа╓ "Доступу нема", а конкретн╕ше - не зважаючи не те,
          що ми хочемо виконувати файл, система не дозволя╓ цього
          робити. 

</UL>
<P>
Д.Ч.:
<UL>
  <LI> Що ж дал╕?

</UL>
<P>
А.:
<UL>
  <LI> Дал╕-  <U>Правило перше:</U> 

</UL>
<P>
Треба зробити файл вашо╖ програми зд╕бним до виконання
(executable). Той, хто ма╓ досв╕д роботи з MSDOS та його пох╕дними 
Windows'ами, зна╓, що в потойб╕чному св╕т╕ розширення файлу (те, що
йде в ╕мен╕ файлу п╕сля крапки) визнача╓, чи може виконуватися цей
файл чи н╕. Виконуються т╕льки файли з розширеннями com, exe та bat. В
св╕т╕ Мак╕нтош╕в належн╕сть файлу до програм визнача╓ться типом файлу
(який запису╓ться в ресурсн╕й г╕лц╕ файлу. Той, хто не зна╓ ╕ не
здогаду╓ться, що таке "ресурсна г╕лка" нехай сприйме це як ще один
факт в╕д якого нема╓ н╕яко╖ корист╕ ╕ якими так переповнене наше
життя). Щоб система виконувала файл, як програму (могла передати на
нього управл╕ння - говорячи по-розумному), файл повинен мати тип APPL.

<P>
В Юн╕кс╕ ж все визнача╓ться дозволами (eng. permissions) на файл. Щоб
система виконала файл, як програму, в╕н повинен мати дозв╕л на
виконання. ╤ не просто дозв╕л, а дозв╕л для певного користувача. Не
дуже вдаючися у подробиц╕ дозвол╕в та р╕зниц╕ в правах користувач╕в,
зазначу зразу, що команда для встановлення потр╕бних для виконання
дозвол╕в буде така:

<PRE>
         chmod +x mytest.pl
</PRE>

<P>
Деяка розшифровка: остання частина команди означа╓ файл, якому
встановлюються дозволи, chmod походить в╕д "change mode", а +x
означа╓, що треба додати дозволи на виконання до цього файлу. П╕сля
виконання ц╕╓╖ команди, виконувати наш скрипт буде дозволено
будь-кому. Можливо також селективне встановлення дозвол╕в в залежност╕
в╕д приналежност╕ користувача до т╕╓╖ або ╕ншо╖ групи. За подальшою
╕нформац╕╓ю див╕ться "man chmod". 

<P>
Нетерплячий Читач:<BR>
"Ну що, встановили дозволи, то-ж давай виконувати!.."


<PRE>
            dk@sophy$ chmod +x mytest.pl 
            dk@sophy$ ./mytest.pl 
            ./mytest.pl: print: command not found
            dk@sophy$
</PRE>

<P>
Н.Ч.: "Га? Що дал╕?"

<P>
А.: Дал╕ --  <U>Правило друге:</U>  

<P>
Мало того, щоб Юн╕кс знав, що файл можна виконата, ще йому треба
вказати, як саме виконувати вашу програму.  В Юн╕кс╕ ╓ для цього
зас╕б, який найб╕льш в╕домий як "magic number", або чар╕вне
число. (Майже те-ж саме, що ╕ чар╕вне слово - коли ви хочете запалити,
то мало дозволити перехожому пригостити вас цигаркою, ще треба ╕
сказати "Будь-ласка"). Це чар╕вне число - два перших байти (дв╕ перших
л╕тери) файлу. Прочитавши два цих перших байти Юн╕кс завжди може
сказати до якого типу належить цей файл. Два перших байти будь-якого
скрипту (будь-то скрипт у Перл╕, sh, csh чи ще чому завгодно --
наприклад нав╕ть такому екзотичному скрипт╕ як gnuplot -- систем╕ для
граф╕чного зображення числових даних) повинн╕ бути  <TT>"#!"</TT>  (без лапок,
звичайно).

<P>
Побачивши цих два маг╕чних байти, система почне придивлятися до файлу
уважн╕ше, щоб визначити, який ╕нтерпретатор ╖й використовувати. 

<PRE>
     <U>До реч╕:</U> 
          
          Вс╕ командн╕ оболонки, вс╕ ц╕ sh, csh, ..sh ╓
          ╕нтерпретаторами, Перл також ╓ ╕нтерпретатором, правда трохи
          ╕ншого типу. Його можна назвати комп╕люючим ╕нтерпретатором
          (чи може ╕нтерпретуючим комп╕лятором? А взагал╕, яка
          р╕зниця?!). Тобто, зам╕сть того, щоб читати по одному рядку
          ╕ виконувати цей рядок, як роблять б╕льш╕сть командних
          оболонок, Перл чита╓ зразу весь файл, комп╕лю╓ його весь, а
          вже пот╕м викону╓. Це значно зб╕льшу╓ швидк╕сть роботи
          скрипт╕в у Перл╕.
</PRE>

<P>
Тож в першому рядку файлу повинно бути записано, яким ╕нтерпретатором
повинна користуватися система.

<P>
Але зв╕дки ж буде знати користувач, що треба записати в цьому першому
рядку? Тут саме ╕ час знову згадати про команду which. Пам'ята╓те, як
там було (в усп╕шному вар╕ант╕): 

<P>
  Я:    "Which perl?"<BR>
  Вона: "/usr/bin/perl"

<P>
Саме оцей рядок, разом ╕з чар╕вним словом треба написати в першому
рядку програми. П╕сля цього наша програма вироста╓ аж вдв╕ч╕, зам╕сть
одного рядка в н╕й ста╓ два:


<PRE>
       #!/usr/bin/perl
       print "Hello! I have written my first program! \n"
</PRE>


<P>
Що станеться, якщо програм╕ст забуде написати маг╕чне слово, або ж
допустить помилку в написанн╕ повного рядка до Перл-╕нтерпретатора?

<P>
В Юн╕кс╕ ╓ домовлен╕сть, що якщо не вказана повна адреса
╕нтерпретатора, то Юн╕кс вважа╓, що цей скрипт написаний для
найпрост╕шо╖ командно╖ оболонки - для  <TT>/bin/sh</TT>  В нашому
випадку це означа╓, що  <TT>/bin/sh</TT>  намагатиметься виконати
команду  <TT>print</TT> , яко╖ нема╓ в мов╕  <TT>sh</TT> , ╕
звичайно вида╓ помилку про це.

<P>
Якщо ж в маршрут╕ до ╕нтерпретатора допущена помилка (або, наприклад,
якщо ви на ╤нтернет╕ знаходите програма, яку так довго шукали. А ту
програму написав хтось, у кого Перл був встановлений в зовс╕м ╕ншому
м╕сц╕), то пов╕домлення про помилку буде зовс╕м ╕ншим. Щоб не бути
голосл╕вним, давайте проведем досл╕д.

<P>
Для початку давайте впевнимося, що наша новенька програмка працю╓ так,
як нам цього хочеться:

<PRE>
       dk@sophy$ ./mytest.pl
       Hello! I have written my first program! 
       dk@sophy$ 
</PRE>

<P>
Так... добре! Тепер зм╕н╕ть перший рядок, так щоб в ньому було
написане щось зовс╕м ╕нше. Наприклад таке:

<PRE>
       #!/USR/BIN/PERL
</PRE>

<P>
   <U>До реч╕:</U> 
<PRE>
        Для тих, хто ще не звик до Юн╕кса, нагадаю, що вс╕ назви файл╕в в
        Юн╕кс╕ в╕др╕зняють велик╕ ╕ мал╕ л╕тери. ╤ тому
        <em>#!/USR/BIN/PERL</em> це зовс╕м не те, що <em>#!/usr/bin/perl</em>,
        ╕ нав╕ть не те, що <em>#!/Usr/bin/perl</em>.)
</PRE>

<P>
 Викона╓мо ту-ж саму команду, що ╕ перед цим. ╤...

<P>
В залежност╕ в╕д того, в як╕й оболонц╕ ви в даний момент знаходитесь
ви можете отримати р╕зн╕ в╕дпов╕д╕:


<P>
csh:
<PRE>
        dk@sophy$ ./mytest.pl
        ./mytest.pl: Command not found.
        dk@sophy$ 
</PRE>

<P>
bash:

<PRE>
        dk@sophy $ ./mytest.pl
        bash: ./mytest.pl: No such file or directory
        dk@sophy $ 
</PRE>

<P>
sh:
<PRE>
        sh$ ./mytest.pl
        sh: ./mytest.pl: No such file or directory
        sh$ 
</PRE>


<H3><A NAME="section-1.1.7">Зм╕нна PATH</A></H3>

<P>
Чому системн╕ команди так╕, наприклад, як  <TT>ls,</TT>   <TT>echo,</TT>   <TT>startx</TT>  та ╕нш╕
можна виконувати без всяких крапок та косих, що йдуть перед назвою
файлу? ╤ чому, коли я працював в ДОС╕, я м╕г створити BATCH-файл
"MYFILE.BAT" ╕ просто надрукувати в командному рядку "MYFILE" ╕ воно
працювало? Чому вс╕ ц╕ складнощ╕ з Юн╕ксом? Чому, якщо файл
знаходиться осьо тут, прямо в мене перед очима, в ц╕й директор╕╖, в
як╕й я зараз ╓, чому я повинен перед ╕менем файлу писати ще як╕сь
дурниц╕? Ось м╕й файл "mytest.pl", чому я не можу написати "mytest"?
Чому я не можу написати "mytest.pl"? Чому я обов'язково маю писати
"./mytest.pl"? 

<P>
Як виявля╓ться вс╕ ц╕ дурниц╕, як зда╓ться на перший погляд, не ╓
зовс╕м дурницями, а мають св╕й великий пота╓мний зм╕ст. Обидв╕ системи
(ДОС та Юн╕кс) мають поняття про таку р╕ч, як зм╕нна середовища  <TT>PATH</TT> ,
яка ╓ просто перел╕ком директор╕й, в яких система веде пошук команд
для виконання. Але використання ц╕╓╖ зм╕нно╖ сутт╓во в╕др╕зня╓ться в
двох системах. 

<P>
 <U>По-перше</U> ,  <STRONG>про те в чому в╕др╕зняються ДОС ╕ Юн╕кс?</STRONG> 


<P>
Коли в ДОС╕ користувач друку╓ команду в командному рядку, система
почина╓ шукати цю команду. Посл╕довн╕сть пошуку така:
<UL>
  <LI> чи ╓ це внутр╕шня команда системи?
  <LI> чи ╓ в дан╕й директор╕╖ файл з такою назвою?
  <LI> чи ╓ файл з такою назвою в директор╕ях вказаних в зм╕нн╕й
           <TT>PATH</TT> ?

</UL>
<P>
До цього додаються ще деяк╕ вар╕ац╕╖ щодо розширень файлу. Тобто, коли
користувач друку╓ назву команди без розширення, то файли "*.COM"
будуть пр╕оритет  перед файлами "*.EXE", тощо.

<P>
Оск╕льки Юн╕кс не обмежу╓ться трьома (чи нав╕ть п'ятьма) розширеннями
файл╕в, як╕ можуть бути програмами, то, звичайно-ж, треба завжди
вказувати повну назву файлу, разом з розширенням.

<P>
В Юн╕кс╕ посл╕довн╕сть пошуку програми  <TT>*</TT>  ма╓ трохи ╕нший вигляд:
<UL>
  <LI> чи ╓ це внутр╕шня команда системи?
  <LI> чи ╓ файл з такою назвою в директор╕ях вказаних в зм╕нн╕й
           <TT>PATH</TT> ?


</UL>
<P>
<hr size=1 noshade width=100 align=left><font size=-1><dl><dt><b>(*) - </b><dd> -
Може трохи зап╕зно, але все-таки зауважу, що все це стосу╓ться т╕льки
випадку, коли користувач вводить команду без директор╕╖. Якщо
користувач друку╓ в командному рядку  <TT>/bin/ls</TT>  , то система н╕чого не
шука╓, вона просто бере ╕ викону╓ цю команду. Нав╕ть, якщо користувач
вводить неповний маршрут до команди, як наприклад  <TT>./mytest.pl</TT>  ,
система не проводячи пошуку просто переходить до виконання. ╤ т╕льки
коли я надрукую  <TT>mytest.pl</TT> , т╕льки тод╕ система почне шукати цей файл
у вс╕х директор╕ях, що вказан╕ у  <TT>PATH</TT> .
</dl></font>

<P>
Як бачите в╕дсутня частина з пошуком в дан╕й директор╕╖. Чи можна
зробити так, щоб система все-таки шукала файл в дан╕й директор╕╖?
Можна. Для цього треба додати крапку (".") в маршрут пошуку - тобто в
 <TT>PATH</TT> . Але про це йдеться в...

<P>
 <U>По-друге</U> :  <STRONG>чому цього не варто робити?</STRONG> 


<P>
Для безпеки. Перш за все. Пом╕чено давно, що парано╖ки сплять
спок╕йн╕ше в╕д оптим╕ст╕в. Бо на вс╕х дверях у них висять величезн╕
запори, на в╕кнах - ╜рати, а сам╕ в╕конниц╕ позабиван╕ трьохдюймовими
цвяхами.

<P>
Мати крапку в зм╕нн╕й  <TT>PATH</TT>  вважа╓ться (╕ справедливо вважа╓ться) дуже
небезпечно. Розгляд цього питання аж занадто далеко в╕дходить в╕д
програмування в Перл╕, тому я зупинюся просто на констатуванн╕ цього
факту без будь-яких пояснень, а перейду до пояснення того, як 
зробити так, щоб ваша програма виконувалася ╕ щоб вам не треба було
кожного разу друкувати назви директор╕й в командному рядку.

<P>
Можлив╕ два п╕дходи до цього.
<UL>
  <LI> або зм╕нити зм╕нну  <TT>PATH</TT> ;
  <LI> або ж записати файл з програмою у ту директор╕ю, яка вже
вказана в зм╕нн╕й  <TT>PATH</TT> .

</UL>
<P>
Перш за все - а як д╕знатися, як╕ директор╕╖ записан╕ в зм╕нн╕й
 <TT>PATH</TT> . Виконайте для цього в командн╕й оболонц╕ команду:


<PRE>
        dk@sophy$ echo $PATH
        /usr/local/qt/bin:/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin
        dk@sophy$ 
</PRE>
                


<P>
Назви директор╕й в╕дд╕ляються одна в╕д одно╖ двокрапками. Якщо
ви ма╓те дозв╕л на запис в одну ╕з директор╕й виданих командою echo,
то просто можете скоп╕ювати св╕й файл в цю директор╕ю. Якщо ж вс╕
директор╕╖ недоступн╕ для запису, то залиша╓ться вар╕ант з
модиф╕кац╕╓ю  <TT>PATH</TT> . Команда для цього зм╕ню╓ться в залежност╕ в╕д того,
яким shell'ом ви користу╓тесь. Тому, зразу к╕лька вар╕ант╕в. Для
конкретност╕ в╕зьмемо директор╕ю  <TT>/tmp/bin</TT>  ╕ додамо ╖╖ до зм╕нно╖
 <TT>PATH</TT> . 

<P>
 <TT>csh</TT>  та його пох╕дн╕ ( <TT>tcsh</TT> ):

<P>
    setenv PATH $PATH:/tmp/bin


<P>
 <TT>sh</TT>  та його пох╕дн╕ ( <TT>ksh</TT> ,  <TT>bash</TT> ,  <TT>ash</TT> ):

<PRE>
      PATH=$PATH:/tmp/bin
      export PATH
</PRE>


<P>
В  <TT>bash</TT>  та  <TT>ksh</TT>  можливий також дещо коротший вар╕ант:


<PRE>
        export PATH=$PATH:/tmp/bin
</PRE>
        

<P>
Ц╕ зм╕ни пропадуть в наступн╕й сес╕╖ (п╕сля того, як ви вийдете з
системи ╕ вв╕йдете в не╖ знов). Тому, щоб зробити ц╕ установки
пост╕йними ц╕ команди треба додати до одного з конф╕╜урац╕йних файл╕в
вашого shell'у. Для csh (tcsh) це буде файл .login або .cshrc в
домашн╕й директор╕╖. Для sh (ksh, zsh, bash, ash) це - файл
.profile. bash також ма╓ к╕лька ╕нших файл╕в, як╕ визначають
середовище користувача. Ц╕ файли - [[.bashrc, .bash_login,
.bash_profile]]. Але в╕дм╕нност╕ м╕ж всима цими файлами краще
пояснен╕ в  <TT>man bash</TT> .

<P>
А на зак╕нчення цього розд╕лу все таки не можу втриматися в╕д ще
одн╕╓╖ шпильки на адресу В╕ндовс╕в. Чому, знаючи про явний провал в
безпец╕, ДОС все-таки дозволя╓ виконувати файли в поточн╕й директор╕╖?
Та тому що, так чи ╕накше ви будете перевстановлювати систему (якби
вона не називалась: DOS, Window NT, 3.1, 95, 98, 2000, 3000 ... 15000
- не дай Боже дожити до такого (!) ) в середньому дв╕ч╕ на
м╕сяць. Тому яка р╕зниця в╕д чого вона загинула - чи в╕д "." в PATH, чи
в╕д того, що MS Word'у не сподобалось те, що ви надрукували, а чи ще
в╕д чого?

<H3><A NAME="section-1.1.8">П╕дсумок розд╕лу</A></H3>

<P>
На цьому розд╕л про виконання програм написаних у Перл╕ можна вважати
зак╕нченим.  Дуже мало в цьому розд╕л╕ йшло мови власне про
програмування в Перл╕. Розд╕л стосувався (як можливо хтось дуже
уважний пом╕тив), про загальн╕ вимоги до будь-якого скрипту в Юн╕кс╕,
не т╕льки скрипту написаного в Перл╕. Але розум╕ння основ виконання
програм повинно передувати написанню програм. Ви ж не збира╓тесь
писати програми, як╕ не виконуються?

<P>
А хто вже ц╕ основи знав, той все одно н╕чого не втратив, бо я не можу
пов╕рити в те, що в╕н марнував св╕й власний час на ще одне
перечитування.

<P>
Цей розд╕л я зак╕нчу п╕дсумуком т╕льки-що написаного.

<OL>
  <LI> Знайти ╕нтерпретатор Перла в систем╕ допоможе команда which.  ╤ншими
  засобами для в╕дшукання потр╕бно╖ команди в Юн╕кс╕ та Л╕накс╕ ╓ так╕
  команди, як locate, find, rpm.

  <LI> Параметр -v в командному рядку Перла дасть можлив╕сть д╕знатися про
  верс╕ю ╕нтерпретатора на даному комп'ютер╕.
      
  <LI> Найпрост╕ш╕ скрипти в Перл╕ можна писати прямо в командному
  рядку. Для цього:

  <UL>
    <LI> використову╓ться параметр -e в командному рядку;

    <LI> скрипт, що    йде п╕сля цього треба брати у лапки.

  </UL>
  <LI> Для того, щоб перл╕вський скрипт можна було виконувати не
  використовуючи форму "perl (назва_файлу)", а просто як
  "(назва_файлу)" треба задовольнити так╕ умови:

  <UL>
    <LI> файл скрипту повинен мати дозв╕л на виконання в╕дпов╕дним
           користувачем;

    <LI> в першому рядку файлу треба вказати повний маршрут до
          ╕нтерпретатора Перлу в ваш╕й систем╕. 

  </UL>
  <LI> Щоб виконувати програму, не вказуючи повний маршрут, що веде до не╖,
  потр╕бно або встановити (скоп╕ювати в) ╖╖ в директор╕╖, яка вказана в
  зм╕нн╕й середовища  <TT>PATH</TT>  користувача, або зм╕нити зм╕нну  <TT>PATH</TT>  таким
  чином, щоб вона включала директор╕ю, яка м╕стить програму
  користувача. 
<H2><A NAME="section-1.2">Основи програмування в Перл╕</A></H2>

</OL>
<P>
В цьому розд╕л╕ я спробую п╕д╕йти трохи ближче до програмування в
Перл╕. Ми вже б╕льше не будемо розглядати питання про те, як написан╕
нами програми повинн╕ виконуватися. Не будемо звертати уваги також ╕
на те, чи ма╓ програма в першому сво╓му рядку " <TT>#!/usr...</TT> ". Якщо
результатом роботи скрипту все ще ╓ "Command not found", то мо╓ю
╓диною порадою будео ще раз уважн╕ше перечитати попередн╕й розд╕л. 

<H3><A NAME="section-1.2.1">Блоки та оператори</A></H3>

<P>
Мабуть зрозум╕ло, що в середньому програми на Перл╕ складаються  з
б╕льше, н╕ж одн╕╓╖ команди. Тому, для того, щоб ╕нтерпретатор розум╕в,
де зак╕нчу╓ться одна команда ╕ почина╓ться ╕нша, повинн╕ ╕снувати
деяк╕ правила, як╕ визначають меж╕ команд. 

<P>
В Перл╕ використову╓ться поняття "блоку", яке ╓ трохи ширшим, н╕ж
команда. Блоком може бути, як одна одинока команда (яка назива╓ться
"оператором"), так ╕ деяка лог╕чно по╓днана посл╕довн╕сть
оператор╕в. Кожен блок повинен зак╕нчуватись крапкою з комою ";". ╤
блок, який склада╓ться з б╕льше, н╕ж одного оператора, береться у
ф╕гурн╕ дужки:

<PRE>
        {
            ...
            ... деякий_перл_оператор;
            ... ╕нший_перл_оператор;
            ... ще_один_перл_оператор;
            ...
         };
</PRE>

<P>
Оск╕льки оператор ╓ не що ╕нше, як блок, який склада╓ться з одного
оператора, то в подальшому я не буду робити велико╖ р╕зниц╕ м╕ж обома
поняттями "оператор" та "блок", ╕ обидва терм╕ни будуть вживатися
р╕вноправно, кр╕м особливих випадк╕в, коли така р╕зниця сутт╓ва. Але в
таких випадках це завжди буде оговорюватися особливо.

<P>
Фраза про те, що _кожен_ блок повинен зак╕нчуватися крапкою з комою ╓,
взагал╕-то, нев╕рною. Якби це було так, то наша програма з першого
розд╕лу не працювала б. В╕рн╕ше буде сказати, що "блоки повинн╕
в╕дд╕лятися один в╕д одного крапкою з комою". З цього виплива╓, що
останн╕й оператор в програм╕ не обов'язково ма╓ мати крапку з комою в
к╕нц╕. Те ж стосу╓ться ╕ останнього оператора в блоц╕. Але поставити
╖╖ не буде великою помилкою.

<H3><A NAME="section-1.2.2">Коментар╕</A></H3>

<P>
Практично вс╕ мови програмування мають в соб╕ ту чи ╕ншу форму
коментар╕в. Коментарем вважа╓ться шматок програми, на який комп╕лятор
чи ╕нтерпретатор не звертають н╕яко╖ уваги. Застосовуються коментар╕
т╕льки для зручност╕ програм╕ст╕в, як╕ мають пот╕м читати цей
код. Гарно в╕дкоментовану програму завжди легше зрозум╕ти.

<P>
В Перл╕ для коментар╕в використову╓ться знак "#". Все що йде п╕сля
цього символу до самого к╕нця рядка вважа╓ться коментарем ╕
╕гнору╓ться Перлом.

<P>
Зважаючи на все сказане ми можемо переписати нашу першу програму у
такому вигляд╕:


<PRE>
       #!/usr/bin/perl
       # This script will print short message on the screen
       # and exit after this.
       # Оск╕льки коментар╕ ╕гноруються, то ╖х можна писати будь-якою мовою

       print "Hello!";

       # Результат роботи цього скрипту такий же, як ╕ попереднього
       print " I have written my first program! \n"
</PRE>


<P>
╤ виконавши його ми отрима╓мо: 


<PRE>
        dk@sophy$ ./mytest.pl
        Hello! I have written my first program! 
        dk@sophy$ 
</PRE>
        
        
<H3><A NAME="section-1.2.3">Зм╕нн╕ та типи даних у Перл╕</A></H3>

<P>
Вс╕ мови програмування оперують зм╕нними. Деяк╕ з мов мають також
поняття констант. Константа - це така зм╕нна, яка не ╓ зм╕нна
(значення яко╖ встановлю╓ться один раз ╕ не зм╕ню╓ться в процес╕
роботи програми). Тобто, це практично одне ╕ те ж. Тому Перл не ма╓
констант. А зм╕нну можна уявити як деяку ком╕рку в яку можуть
вкладатися т╕ або ╕нш╕ дан╕.

<P>
Б╕льш╕сть мов програмування мають поняття про типи даних. Перш, н╕ж
користуватися якоюсь зм╕нною, треба визначитися, до якого типу належить
ця зм╕нна. Тобто, якщо ви будете оперувати ц╕лими числами, то
в╕дпов╕дна зм╕нна повинна бути ц╕лого типу. Якщо вам потр╕бно
оперувати текстовими даними, то зм╕нн╕ повин╕ мати тип символу або
рядка. В загальному випадку, не дозволяться в одн╕й операц╕╖
використовувати дан╕ р╕зних тип╕в. (Тобто, це б╕льше схоже на
запитання: "Що буде, якщо до п'яти центнер╕в додати 2 к╕лометри?"

<P>
В р╕зних мовах ╕снують р╕зн╕ п╕дходи до визначення та оперування
р╕зними типами даних. В деяких мовах вс╕ дан╕ потр╕бно декларувати
перш, н╕ж використовувати. В ╕нших декларувати дан╕ не потр╕бно, але
все визнача╓ться преф╕ксами до назв зм╕нних, тощо. В багатьох мовах
програмування перш, н╕ж оперувати даними р╕зних тип╕в, ╖х треба
перетворити в ╕нший тип. Наприклад, звичайно-ж з точки зору здорово╖
лог╕ки, можна додати ц╕ле число 5 ╕ десятковий др╕б 0,78. Але для
тако╖ операц╕╖ (наприклад в Паскал╕) потр╕бно спочатку 5 перетворити
╕з ц╕лого числа в десятковий др╕б 5,0. Значення числа при цьому не
зм╕ню╓ться, але зм╕ню╓ться тип зм╕нно╖. ╤ п╕сля тако╖ операц╕╖ вже
обидва доданки стають десяктовими дробами, над якими дозволя╓ться
виконувати арифметичн╕ д╕╖.

<P>
Р╕зн╕ мови програмування в╕др╕зняються одна в╕д одно╖ також щодо
операц╕й перетворення даних. Деяк╕ з них вимагають завжди
обов'язкового явного перетворення типу даних. Тобто не можна просто
написати "5 + 0,78", а обов'язково треба написати щось под╕бне до
"(дробове число, числове значення якого дор╕вню╓ 5) + 0,78". ╤нш╕ мови
розум╕ють, в деяких випадках, що до чого ви хочете додати, ╕ роблять
деяк╕ перетворення, покладаючись на правила перетворень даних.

<P>
Перл в цьому в╕дношенн╕ особливий. Тип╕в даних в розум╕нн╕ ╕нших
("дорослих") мов прогрмування в Перл╕ нема╓. ╢ один-╓диний скалярний
тип даних в Перл╕, який покрива╓ вс╕ необх╕дн╕ типи: ц╕л╕ числа,
дробов╕ числа, символи та рядки. ╤ вс╕ необх╕дн╕ перетворення
робляться Перлом неявно, непом╕тно для програм╕ста ╕ робляться вони в
залежност╕ в╕д контексту, в якому це перетворення трапля╓ться.

<P>
Кр╕м скалярного типу даних Перл ма╓ також масиви скаляр╕в та
асоц╕ативн╕ масиви, про як╕ буде трохи дал╕. Вс╕ ц╕ три типи даних
в╕др╕зняються один в╕д одного преф╕ксами. 

<P>
Скалярний тип даних в Перл╕ познача╓ться преф╕ксом "$". Тому, побачивши
написане  <TT>$a= 5</TT>  або  <TT>$b= 'one'</TT>  , ви не помилитесь, якщо скажете,
що обидва ц╕ вирази присвоюють значення не масивам, а скалярним
зм╕нним. Правда, якщо в другому випадку, можна з великою долею
ймов╕рност╕ сказати, що  <TT>$a</TT>  ╓ текстовим рядком, то в першому випадку
н╕чого певного сказати не можна.

<P>
Подив╕ться уважн╕ше на наступн╕ приклади (для деяко╖ лакон╕чност╕ я
буду надал╕ опускати системн╕ запрошення в командному рядку):

<PRE>
        perl -e '$a=5; $b="one"; print $a + $b, "\n"'
        5

        perl -e '$a=5; $b="one"; print $a . $b, "\n"'
        5one
</PRE>

<P>
В першому випадку зм╕нна $a тракту╓ться, як числова зм╕нна (бо
викону╓ться операц╕я додавання) ╕ зм╕нна $b, не ╓ числовою, тому
сума  дор╕вню╓ першому доданку. В другому приклад╕ викону╓ться
операц╕я над двома текстовими рядками <TT>*</TT> . Тому обидв╕ зм╕нн╕
трактуються в цьому випадку, як текстов╕ зм╕нн╕ ╕ ви бачите результат
цього. 

<P>
<hr size=1 noshade width=100 align=left><font size=-1><dl><dt><b>(*) - </b><dd>
Операц╕я, яка познача╓ться крапкою "." по╓дну╓ дв╕ текстов╕ зм╕нн╕.
Результатом ц╕╓ю д╕╖ ╓ трет╕й рядок, який дор╕вню╓ першому ╕ другому
рядкам разом взятим. Англ╕йською мовою операц╕я об'╓днання двох рядк╕в
назива╓ться "concatenation". Не маючи кращого вар╕анту, я буду називати
╖╖ конкатенац╕╓ю (на слух сприйма╓ться як дуже розумне слово - ╕ це
основна причина його вживання).<BR>
</dl></font>


<P>
Можлив╕ нав╕ть зовс╕м дик╕ ситуац╕╖, коли в одн╕й частин╕ скрипту одна
╕ та ж зм╕нна тракту╓ться по одному, ╕ в ╕нш╕й частин╕ - по ╕ншому . В
наступному приклад╕ зм╕нна $a в одному випадку виступа╓ як текстова
зм╕нна, а в ╕ншому як числова.

<PRE>
        perl -e '$a=5; $b="one"; $c=3;  print $a . $b, "\n", $a + $c ,"\n"';
        5one
        8
</PRE>

<P>
Або ще один, нав╕ть б╕льш дивний, вар╕ант, в якому до результату
конкатенац╕╖ двох текстових зм╕нних дода╓ться число. Тобто, спочатку до
п'яти к╕лометр╕в дода╓ться ще ш╕сть к╕лометр╕в, ╕ пот╕м результат
склада╓ться з двадцятьма коровами:

<PRE>
            perl -e '$a=5; $b=15; $c=3; $d =$a . $b;  print $d, "\n", $d + $c ,"\n"';
            515
            518
</PRE>


<H3><A NAME="section-1.2.4">Використання лапок</A></H3>

<P>
В самому першому приклад╕ я звертав увагу на те, що порядок
використання лапок - важливий. Давайте трохи зупинимось на цьому
питанн╕.

<P>
Перш за все - нав╕що взагал╕ використовувати лапки? Чи не прост╕ше
просто написати що-небудь типу:

<PRE>
       print Hello! I have written my first program! \n
</PRE>

<P>
Написати можна, але сам╕ можете впевнитися, що працювати це не
буде. Так само, як пишучи твора, ми вид╕ля╓мо в твор╕ пряму мову, так
само потр╕бно вид╕ляти текстов╕ еп╕зоди в програм╕. Текст, взятий в
лапки ╓ прямою мовою в Перл-програм╕.

<P>
Ну, з цим зрозум╕ло, це була проста задача. Але як бути з оцими
р╕зними типами лапок: з одинарними (''), та з подв╕йними ("") ?

<P>
Проведемо деяк╕ досл╕дження:

<PRE>
        $a=" шматок тексту "; 
        $b=" ще один шматок "; 
        print $a . $b, "\n";
        print "$a  $b ","\n";
        print '$a  $b ',"\n";

        ./mytest.pl
         шматок тексту  ще один шматок 
         шматок тексту    ще один шматок  
         $a  $b
</PRE>

<P>
Що в╕дбува╓ться? Перший вар╕ант зрозум╕лий: просто конкатенуються дв╕
текстов╕ зм╕нн╕ ╕ результат цього об'╓днання друку╓ться. Другий рядок
схожий на перший, але в ньому ╓ зайвий пропуск, але трет╕й вар╕ант
сутт╓во в╕дм╕нний в╕д обох попередн╕х.

<P>
Почнемо з третього вар╕анту, бо з ним роз╕братися прост╕ше. Все взяте
в одинарн╕ лапки друку╓ться так, як воно написане, тобто, не зважаючи
на те, що всередин╕ лапок записане щось таке, що за виглядом нагаду╓
скалярн╕ зм╕нн╕ -  <TT>$a $b</TT> . Але написане всередин╕ лапок тракту╓ться
не як зм╕нн╕, а як просто текст, який друку╓ться
буквально. ╤нтерпретатор Перла "не бачить" того, що знаходиться
всередин╕ одинарних лапок.

<P>
В другому вар╕ант╕ (подв╕йн╕ лапки) все, що лежить всередин╕ лапок, ╓
видимим для Перла - подв╕йн╕ лапки "прозор╕". ╤ Перл п╕дставля╓
зам╕сть зм╕нних ╖х значення, або як ще кажуть Перл розширя╓ значення
зм╕нних.

<P>
Це стосу╓ться не т╕льки оператора  <TT>print</TT> , але ╕ будь яко╖ ╕ншо╖
операц╕╖ в Перл╕. Значення в подв╕йних лапках завжди розширяються:

<PRE>
        $a=" шматок тексту "; 
        $b=" ще один шматок "; 
        $c = "$a плюс $b";
        $d = '$a плюс $b';
        print $c, "\n";
        print $d, "\n";

        ./mytest.pl
         шматок тексту  плюс  ще один шматок 
         $a плюс $b
</PRE>
        
<P>
Все, про що йшлося в останн╕х абзацах, носить назву "цитування" -
quoting. ╤ справд╕, все це дуже схоже на те, як в текст╕ вставляються
цитати. Чи ╓ ще ╕нш╕ правила цитування, кр╕м двох вже описаних правил
з подв╕йними та одинарними лапками? ╢, ще одне. Коли потр╕бно
захистити в╕д розширення один ╓диний символ, перед ним ставиться
зворотня коса (або backslash) - "\". Наступний приклад демонстру╓ це
правило:


<PRE>
         $a=" шматок тексту "; 
         $b=" ще один шматок "; 
         print "$a плюс $b";
         print "$a плюс \$b";

         ./mytest.pl
          шматок тексту  плюс  ще один шматок 
          шматок тексту  плюс $b
</PRE>

<P>
Але ситуац╕я з розширенням зворотьо╖ косо╖ насправд╕ дещо складн╕ша,
н╕ж з розширенням зм╕нних. Всередин╕ одинарних лапок вона
розширю╓ться. В наступному приклад╕ зворотня коса "маску╓" одинарну
лапку, ╕ через це Перл вида╓ помилку.

<P>
perl -e "print '\'"<BR>
Can't find string terminator "'" anywhere before EOF at -e line 1.


<H3><A NAME="section-1.2.5">Не скалярн╕ типи даних</A></H3>

<P>
Кр╕м описаного вже типу скалярних даних (як╕, як ми бачили, можуть в
Перл╕ бути чим завгодно) Перл ма╓ ще масиви скалярних даних та
асоц╕ативн╕ масиви скаляр╕в. 
<PRE>
         <STRONG> META </STRONG> 

          * масиви
          * асоц╕ативн╕ масиви - hash
</PRE>
<H2><A NAME="section-1.3">Робота з файлами та операц╕╖ вводу-виводу</A></H2>

<P>
Питання роботи з файлами насправд╕ ╓ трохи ширшим, н╕ж просто перел╕к
операц╕й для того, щоб прочитати файл на диску або щоб створити новий
файл чи дописати щось до вже ╕снуючого. В Перл╕ (особливо в тих
системах, як╕ п╕дтримують командний рядок -- тобто не Macintosh -- та
стандартн╕ дескриптори файл╕в, так╕ як  <TT>STDIN</TT> ,  <TT>STDOUT</TT> ,  <TT>STDERR</TT>  -- тобто
не Windows) питання роботи з файлами включа╓ в соб╕ так╕ операц╕╖, як
виконання системних команд, перехоплення виводу в╕д них та його
використання, в╕дкриття системних канал╕в (pipe) ╕з Перл-програми,
тощо. Якщо Ви не дуже розбира╓тесь у терм╕ноло╜╕╖, яка тут так часто
вжива╓ться, ми спробу╓мо з цим трохи дал╕ роз╕братися, а про все, що
не зрозум╕ло з пояснення в ц╕й книжц╕, доведеться почитати в книжц╕ по
Юн╕ксу.

<H5><A NAME="section-1.3.1.1.1">Щось стандартне</A></H5>
Розгляд операц╕й вводу-виводу ми розпочнем з найпрост╕ших ╕ найб╕льш
вживаних оператор╕в - читання з  <TT>STDIN</TT>  та виводу на  <TT>STDOUT</TT> . 

<P>
Але що то таке -  <TT>STDIN</TT> ? Це ╓ скорочення в╕д англ╕йського "standard
input" ╕ означа╓ "стандартний вв╕д". Тепер вже зрозум╕ло, що "standard
output" або  <TT>STDOUT</TT>  - це стандартний вив╕д, а "standard error" - це
 <TT>STDERR</TT> , який за неможлив╕стю в╕дшукати б╕льш пристойного
укра╖нського екв╕валенту, я перекладаю як "стандартний пристр╕й для
пов╕домлення помилок". Розум╕ння правил роботи з цими пристроями ╓
сутт╓вим для розум╕ння роботи б╕льшост╕ програм у Юн╕кс╕, оск╕льки
абсолютна б╕льш╕сть програм, написаних в "юн╕кс╕вському стил╕", вм╕ють
читати дан╕ з  <TT>STDIN</TT> , передавати результати сво╓╖ роботи на STDOOUT
та пов╕домляти про помилки в робот╕ на  <TT>STDERR</TT> .

<P>
Оск╕льки поняття "файл" використову╓ться в Юн╕кс╕ дуже часто, ми
говоритимо дал╕ про стандартний вв╕д, вив╕д та пристр╕й для
пов╕домлення помилок, як про звичайн╕ файли. ╤ в сво╖й сут╕ вс╕ ц╕
тро╓ дуже мало в╕др╕зняються в╕д звичайних файл╕в (тобто файл╕в на
диску). В╕дм╕нн╕стю з точки зору програм╕ста ╓ т╕льки те, що вс╕ ц╕
тро╓ ╓ вулицями з односторонн╕м рухом. ╤з  <TT>STDIN</TT>  можна т╕льки
читати, в  <TT>STDOUT</TT>  та  <TT>STDERR</TT>  можна т╕льки писати.

<P>
Перш, н╕ж братися до вивчення програмування з застосуванням нових для
нас понять, давайте спробу╓мо роз╕братися з ними на простих прикладах.
Розглянемо дуже просту команду  <TT>cat (1)</TT> .  Можна було-б описати цю
команду, як таку, яка роздрукову╓ один або к╕лька файл╕в на екран╕
дисплея. ╤ це буде в╕рно до деяких п╕р. Так, наприклад, команда
         
<PRE>
         cat myfile.txt myfile2.txt
</PRE>

<P>
д╕йсно не зробить н╕чого надприроднього. Вона просто надруку╓ файли з
назвами  <I>myfile.txt</I>  та  <I>myfile2.txt</I>  на екран╕ один за одним. Але
якщо зм╕нити цю команду на таку:

<PRE>
         cat myfile.txt myfile2.txt > myfiles.txt
</PRE>

<P>
то все зм╕ниться дуже швидко. Зам╕сть того, щоб друкувати файли на
екран╕, ця команда з╕лл╓ два файли ╕ запише ╖х обидва в трет╕й файл ╕з
назвою   <I>myfiles.txt</I> . Якщо такого файлу не ╕сну╓, команда його
створить, а якщо в╕н ╕сну╓, то зам╕нить його новим. 

<P>
<hr size=1 noshade width=100 align=left><font size=-1><dl><dt><b>( <U>N.B.</U> ) - </b><dd>
╤нколи при виконанн╕ ц╕╓╖ останньо╖ команди, Ви можете побачити одну з
наступних помилок: 


<PRE>
          <I>якщо Вашою робочою оболонкою ╓  <TT>csh</TT>  або  <TT>tcsh</TT>  </I> 
         cat myfile.txt myfile2.txt > myfiles.txt
         myfiles.txt: File exists

або       <I> якщо Ви працю╓те в  <TT>bash</TT> '╕ </I> 

         cat myfile.txt myfile2.txt > myfiles.txt
         bash: myfiles.txt: cannot overwrite existing file
</PRE>



<P>
Це означа╓, що Ви пробу╓те переписати командою  <TT>cat</TT>  вже ╕снуючий
файл. При цьому зм╕нна `noclobber' встановлена в Ваш╕й командн╕й
оболонц╕. ╤снують два можливих шляхи вир╕шення ц╕╓╖ проблеми:

<P>
 <U>Перший</U>  - в╕дшукати де саме в Ваших стартових скриптах ( <TT>.profile</TT> ,
 <TT>.login</TT> ,  <TT>.bashrc</TT>  чи  <TT>.cshrc</TT> ) встановлю╓ться ця зм╕нна ╕ в╕дм╕нити цю
установку (Установка ма╓ такий вигляд:  <TT>set noclobber</TT>  або
 <TT>set -o noclobber</TT> ), 

<P>
або  <U>Другий</U>  - використати такий синтаксис команди:

<PRE>
         cat myfile.txt myfile2.txt >| myfiles.txt
</PRE>

<P>
</dl></font>    

<P>
Саме тут ╕ виявля╓ться, що визначення команди  <TT>cat</TT> , як тако╖, що
роздрукову╓ файли на екран╕, яке було дане всього к╕лька абзац╕в тому
вже по сут╕ не в╕рне. Але в робот╕ команди н╕чого не зм╕нилося. Отже
проблема скор╕ше з нашим визначенням. Тому в╕рним визначенням команди
буде таке: "Команда  <TT>cat</TT>  конкатену╓ файли, як╕ вказуються в
командному рядку ╕ роздрукову╓ ╖х на стандартний вив╕д." Просто в
першому випадку стандартним виводом був дисплей системи, а в другому -
файл на диску. Стандартним виводом для команд ╓ дисплей комп'ютера,
якщо не вказано ╕накше. В тому випадку, коли особливо сказано, що
вих╕дн╕ дан╕ мають бути записаними у файл (тобто  <TT>">file"</TT> , командна
оболонка перебира╓ на себе функц╕╖ по п╕дтриманню такого файлу та
пересиланню у нього даних в╕д команди.

<P>
 <U>В╕дм╕тьте:</U>  Записом даних у файл займа╓ться не сама команда, а
командна оболонка ( <I>shell</I> ). Тому, анало╜╕чно працюють вс╕ команди
Юн╕кса. Тож варто весь час пам'ятати, що ц╕ команди друкують не на
екран╕, а на  <TT>STDOUT</TT> .

<P>
╤нш╕ дв╕ команди допоможуть нам трохи роз╕братися з  <TT>STDIN</TT>  та
 <TT>STDOUT</TT>  разом. Розглянемо для початку таку команду, як
 <TT>bc(1)</TT> . Документац╕я до  <TT>bc</TT>  визнача╓ його, як мову калькулятора
з дов╕льною точн╕стю. Якщо Ви н╕коли до цього не користувалися ц╕╓ю
командою, проведемо коротенький екскурс в основи користуванням
нею. Коли Ви просто в командному рядку надруку╓те  <I>bc</I> , Ви
потрапля╓те в ╕нтерактивний режим роботи калькулятора. Тут Ви можете
виконувати арифметичн╕ д╕╖ дов╕льно╖ точност╕ ╕ складност╕ над
(Увага!)  <STRONG>ц╕лими</STRONG>  числами. Ви просто набира╓те д╕╖ на клав╕атур╕,
тиснете  <I>Return</I>  ╕ ма╓те результат. Ось, наприклад, що я маю на
сво╓му екран╕:

<PRE>
         $ bc
         bc 1.05
         Copyright 1991, 1992, 1993, 1994, 1997, 1998 Free Software Foundation, Inc.
         This is free software with ABSOLUTELY NO WARRANTY.
         For details type `warranty'. 
         2+2
         4
         5/2
         2
         quit
         $
</PRE>


<P>
Я просто додав 2 ╕ 2 ( <TT>2+2 <I>Return</I> </TT> ), а пот╕м розд╕лив 5 на 2
( <TT>5/2 <I>Return</I> </TT> ).

<P>
В такому простому (звичайному калькуляторному) режим╕ використання
команда сприйма╓ дан╕ ╕з  <TT>STDIN</TT>  (яким в цьому випадку ╓ клав╕атура
комп'ютера) ╕ переда╓ результати роботи на  <TT>STDOUT</TT>  (як ми вже
зна╓мо з попередньо╖ дискус╕╖, ним ╓ екран комп'ютера). Але Юн╕кс би
не був Юн╕ксом, якби все було так просто - ╓ соб╕ програма
калькулятора, раху╓ш в ньому що тоб╕ потр╕бно, запису╓ш результат на
пап╕рц╕ ╕ п╕сля цього з пап╕рця перепису╓ш у текстовому редактор╕
циф╕рки туди, де вони потр╕бн╕. Н╕! В Юн╕кс╕ люди поводять себе
╕накше. Коли мен╕, скаж╕мо, треба перевести IP-адресу, виражену в
десятков╕й форм╕ у ш╕стнадцяткове ╖╖ подання, я займусь тим, що напишу
скрипт, який буде виконувати все одн╕╓ю командою. На написання скрипту
у мене п╕де вп'ятеро б╕льше часу, н╕ж на обчислення цих даних за
допомогою калькулятора ╕ пап╕рця, але ж у мене буде готовий скрипт,
який я зможу використати наступного разу, коли мен╕ потр╕бно буде
зробити таке саме перетворення. Одна т╕льки б╕да - навряд чи мен╕
коли-небудь знадобиться переводити десятковий IP в
ш╕стнадцятковий... 

<P>
Тож, як написати скрипт (поки-що не Перл, а звичайний шел), який би
переводив числа ╕з одн╕╓╖ системи числення в ╕ншу? Для цього, як Ви
вже мабуть зрозум╕ли, треба зайнятися перенаправленнями  <TT>STDIN</TT>  та
 <TT>STDOUT</TT>  туди-сюди. Тобто, треба вс╕ т╕ команди, як╕ ми друку╓мо на
клав╕атур╕, подати на  <TT>STDIN</TT>  команди  <TT>bc</TT> . Зробити це можна
якоюсь ╕ншою командою, або просто записати у файл. Ми виберемо перший
- командний - шлях. Невеличкий експеримент:

<PRE>
            $ echo "2+2" | bc
            4
</PRE>

<P>
Працю╓! Тепер треба було-б ╕ к╕лька команд  <TT>bc</TT>  п╕дучити... Зробимо
таке: 

<PRE>
            $ echo "obase=16; 127" | bc
            7F
</PRE>

<P>
Команда  <I>obase</I>  в  <TT>bc</TT>  встановлю╓ вих╕дну систему числення, тобто
те в якому вигляд╕ калькулятор вида╓ результати обчислень. Неважко
здогадатися, що  <I>ibase</I>  в такому випадку визнача╓ вх╕дну систему
числення. ╤ тому наступний приклад переводить число ╕з дв╕йково╖
системи у в╕с╕мкову:

<PRE>
            $ echo "obase=8; ibase=2; 11110100010101000101" | bc
            3642505
</PRE>


<P>
Тож ми вже пов╕стю готов╕ до того, щоб написати наш знаменитий
скрипт. Втн буде мати такий вигляд:

<PRE>
            #!/bin/sh
            echo "obase=16; $1" | bc
</PRE>

<P>
Оце ╕ все? Так, все... А працю╓ в╕н так:

<PRE>
            $ ./h2d 20
            14  
            $ ./h2d 100
            64
            $ ./h2d 15 
            F
            $ ./h2d 225
            E1
</PRE>




<H5><A NAME="section-1.3.1.1.2">Трохи б╕льше подробиць про друк у Перл╕</A></H5>

<P>
Як все це сказане про екран та  <TT>STDOUT</TT>  сп╕вв╕дноситься ╕з
програмуванням на Перл╕? Дуже просто.  Оператор  <I>print</I>  Перла друку╓
все, що його просять, не на екран╕, а на  <TT>STDOUT</TT> , кр╕м тих випадк╕в
коли вказано ╕накше. Саме т╕ випадки, коли вказано ╕накше, ми ╕ будемо
розглядати дал╕. 

<P>
Повна форма оператора  <TT>print</TT>  (  <TT>man perlfunc</TT> ) ма╓ наступний
вигляд:

<PRE>
       print FILEHANDLE LIST
</PRE>


<P>
В цьому визначенн╕  <TT>LIST</TT>  ╓ тим списком даних, що ма╓ надрукувати
оператор. До цього моменту ми не вживали  <TT>FILEHANDLE</TT>  ╕ не зна╓мо,
що це таке. Ми обмежимся тим, що будемо розглядати  <TT>FILEHANDLE</TT>  як
саму звичайну зм╕нну спец╕ального типу, яка пов'язу╓ файл, в який
потр╕бно виводити дан╕ з його назвою. Зауважте,  <TT>FILEHANDLE</TT>  - це
 <U>не назва</U>  файлу (так саме, як, наприклад,  <TT>STDOUT</TT>  - теж не ╓
назвою файла)! Це - всього лиш деякий символ, який зв'язу╓ файл ╕з
зовн╕шн╕м св╕том, така соб╕ "ручка в╕д файлу" (саме так можна
перекласти з англ╕йсько╖ "filehandle").

<P>
Нав╕що потр╕бен  <TT>FILEHANDLE</TT> , якщо можна було б просто надрукувати
щось под╕бне до:

<PRE>
        print "/home/user/MyFile.txt" "Hello"
</PRE>


<P>
Причина цього таж сама, що ╕ ╕снування зм╕нних в мовах
програмування. Набагато зручн╕ше оперувати зм╕нними в програмах, н╕ж
╖х значеннями. 

<P>
Перш, н╕ж у файл можна буде надрукувати будь-що, його треба
в╕дкрити. П╕сля зак╕нчення виводу у файл, його треба закрити. Хоча ця
остання операц╕я ╕ необов'язкова - п╕сля виконання скрипту, вс╕
в╕дкрит╕ файли автоматично закриваються. З точки зору програм╕ста
операц╕я в╕дкриття файлу - це просто операц╕я, яка зв'язу╓ назву файлу
╕з в╕дпов╕дним FILEHANDLE'ом. 

<P>
Добре, якщо кожен файл потр╕бно в╕дкривати перш, н╕ж писати у нього,
то чому ж тод╕ ми н╕чно не говорили ран╕ше про те, що треба в╕дкрити
 <TT>STDOUT</TT>  коли ми прекрасно обходилися без цього в наших попередн╕х
скриптах? Виявля╓ться, що ╓ ще деяк╕ реч╕, якими  <TT>STDIN</TT>  та
 <TT>STDOUT</TT>  в╕др╕зняються в╕д звичайних файл╕в.  В╕дм╕на заключа╓ться в
тому, що  <TT>STDOUT</TT>  не треба в╕дкривати перед записом у нього - в╕н
автоматично в╕дкритий при старт╕ будь-якого Перл╕вського скрипта. Теж
саме стосу╓ться ╕  <TT>STDIN</TT>  - в╕н також автоматично в╕дкрива╓ться при
старт╕ ╕нтерпретатора Перла. Тому то ми можемо без будь-яких зайвих
сл╕в просто написати  <TT>print "Hello"</TT>  ╕ ця операц╕я викона╓ться.

<P>
Тож роз╕бравшись трохи з тим, що треба в╕дкривати, а що не треба, ми
можем на деякий чам забути про те, як саме в╕дкривати файли. Зам╕сть
цього ми можемо зайнятися вивченням використання тих файл╕в, як╕
в╕дкривати не потр╕бно - тобто  <TT>STDIN</TT>  та  <TT>STDOUT</TT> .

<H4><A NAME="section-1.3.1.2">Використання STDIN та STDOUT</A></H4>

<P>
Про  <TT>STDOUT</TT>  вже писалося вище. Поки що ми не можемо додати чогось сутт╓во
нового до того, що вже в╕домо. Тому давайте займемося досл╕дженням
 <TT>STDIN</TT> . Як╕ ╕снують способи використання цього файлу, який так
послужливо в╕дкритий для нас самим Перлом? 

<H5><A NAME="section-1.3.1.2.1">Виконання Юн╕кс команд ╕з Перла</A></H5>

<P>
Мабуть це буде - найпрост╕ший вар╕ант використання  <TT>STDIN</TT>  у Перл
скрипт╕. Хоча, в╕дм╕тимо зразу ж, ╕ не самий розповсюджений, а також у
б╕льшост╕ випадк╕в ╕ не рекомендований для використання через деяк╕ не
зовс╕м улагоджен╕ в╕дносини цього оператора з правилами безпеки. 

<P>
Коли ми в перший раз почина╓мо ц╕кавитися тим, що таке  <TT>STDIN</TT> ,
 <TT>STDOUT</TT>  та  <TT>STDERR</TT>  при вивченн╕ Юн╕кса? Саме тод╕, коли нам
потр╕бно виконати, щось на зразок того, що ми нещодавно проробили ╕з
командою  <TT>cat</TT>  - перехопити  <TT>STDOUT</TT>  в╕д команди ╕ записати його в
файл. Або коли нам потр╕бно перехопити  <TT>STDOUT</TT>  ╕ передати його на
 <TT>STDIN</TT>  ╕ншо╖ команди (мова йде про pipe або про канали в Юн╕кс╕),
як, наприклад у такому випадку:

<PRE>
          ls | wc -l
</PRE>

<P>
Що нам робити, коли ми хочемо використати деяку команду Юн╕кса
╕зсередини програми, написано╖ в Перл╕? Тут на допомогу приходить
оператор `` (зворотн╕ апострофи). Синтаксис оператора дуже простий:

<PRE>
        `<деяк╕ команди Юн╕кса>`
</PRE>


<P>
Оператор викону╓ весь рядок, вказаний м╕ж двома зворотн╕ми апострофами
у командн╕й оболонц╕  <TT>/bin/sh</TT>  або анало╜╕чн╕й до не╖ ╕ поверта╓
весь  <TT>STDOUT</TT>  назад до Перла. Як, напевне вже пом╕тив Допитливий
Читач, тут н╕чого не говориться про  <TT>STDERR</TT> , ╕ в╕рно - цей оператор
просто ╕гнору╓  <TT>STDERR</TT> , тому якщо Ви д╕йсно хочете мати також ╕
 <TT>STDERR</TT>  у сво╓му скрипт╕, то Ви сам╕ ма╓те виконати певн╕ д╕╕ для
цього. Дал╕ ми розглянемо, що саме потр╕бно для цього робити. А
поки-що розберемся з тим, як нам використовувати вив╕д в╕д команди. 

<P>
Вигляд, у якому дан╕ повертаються назад до Перлу залежить перш за все
в╕д того, як використову╓ться оператор ``. Найпрост╕ший вар╕ант - Вам
начхати на те, що саме поверта╓ цей оператор. Тобто, це може бути
тод╕, коли Ви на 100% впевнен╕ в тому, що оператор викона╓ться без
помилок ╕ Вас д╕йсно не хвилю╓, що може видати цей
оператор. 

<P>
<hr size=1 noshade width=100 align=left><font size=-1><dl><dt><b>( <U>Остер╕гайтеся!</U> ) - </b><dd>
Таких ситуац╕й на практиц╕ не бува╓!  Будь-яка команда може виконатися
не так, як Вам би того хот╕лося, особливо, якщо Ваш скрипт ма╓
працювати б╕льш-менш довгий час ╕ ╓ шанси, що за цей час Ви можете
забути, що саме Ви написали ╕ як╕ припущення Ви робили на час
написання скрипту. <BR>
</dl></font>

<P>
Але ми, все-таки, розглянемо, як воно працю╓...

<PRE>
           # touch myprog.log
           # -rw-r--r--   1 root     root            0 Jan  6 18:55 myprog.log
           # perl -e "`mv /var/log/myprog.log /var/log/myprog.log.0`"
           # -rw-r--r--   1 root     root            0 Jan  6 18:55 myprog.log.0
</PRE>


<P>
Цей простенький shell-д╕алог демонстру╓ найпрост╕ше використання
``. (Хоча для такого використання, мабуть ╕ не варто було б
користуватися Перлом, але ми робимо це для навчання). Перл╕вський
оператор в цьому випадку просто зм╕ню╓ назву файлу за допомогою
команди  <TT>mv (1)</TT> . Наступний скрипт робить т╕ж сам╕ д╕╖, але в╕н
пере╕менову╓ к╕лька ре╓страц╕йних ( <I>log</I> ) файл╕в. Скрипт зд╕йсню╓
так звану ротац╕ю ло╜-файл╕в, яка використову╓ться дуже часто
практично в ус╕х сучасних Юн╕ксах.

<PRE>
          #!/usr/bin/perl
          `mv /var/log/myprog.log.3 /var/log/myprog.log.4`;
          `mv /var/log/myprog.log.2 /var/log/myprog.log.3`;
          `mv /var/log/myprog.log.1 /var/log/myprog.log.2`;
          `mv /var/log/myprog.log.0 /var/log/myprog.log.1`;
          `mv /var/log/myprog.log   /var/log/myprog.log.0`;
</PRE>


<HR>

         
<P>
Розглянемо такий дуже простий скрипт:

<PRE>
        #!/usr/bin/perl
        while (<>) { print }
</PRE>


<P>
Що в╕н робить? Та майже н╕чого... Тобто майже н╕чого корисного в план╕
практичного його використання. Але зате в╕н нам допоможе роз╕братися з
тим, що таке  <TT>STDIN</TT> 

<P>
  <STRONG> Meta: </STRONG> 

<UL>
  <LI> операц╕╖ вводу виводу
  <LI> зворотн╕ одинарн╕ лапки ``
  <LI> filehandle ??
  <LI> операц╕я читання -- <>
  <LI> найпрост╕ший вар╕ант читання ╕з  <TT>STDIN</TT>  - while (<>)
  <LI> в╕дкривання та закривання  файлу, код помилки 
  <UL>
    <LI> в╕дкриття файлу на диску 
    <LI> В╕дкриття  <TT>STDIN</TT>  для читання 
  </UL>
  <LI> в╕дкриваня файлу на запис
  <UL>
    <LI> звичайний файл
    <LI> в╕дкривання  <TT>STDOUT</TT>  для запису у файл
  </UL>
  <LI> зм╕нна $_

</UL>
<HR>
<H2><A NAME="section-1.4">Регулярн╕ вирази</A></H2>

<H3><A NAME="section-1.4.1">Регулярн╕ вирази в застосуванн╕ до ╕мен файл╕в</A></H3>

<P>
Чи пробували ви коли-небудь виправляти помилки в надрукованому на
друкарськ╕й машинц╕ текст╕? Н╕чого складного в ц╕й процедур╕
нема╓. Берете пляшечку з чудовою б╕лою р╕диною ╕ авторучку. Акуратно
замальову╓те р╕диною вс╕ т╕ м╕сця, де в слов╕ "головнокомандуючий"
пропущен╕ скр╕зь одн╕ й т╕ ж сам╕ дв╕ л╕тери, а ручкою допису╓те те,
що потр╕бно. Н╕чого складного! Справд╕?  Але, що якщо це злополучне
слово трапля╓ться в текст╕ 156 раз╕в? П╕д к╕нець ц╕╓╖ процедури ви вже
забудете, як╕ л╕тери вам треба вписувати. Саме для тако╖ роботи ╕ були
створен╕ текстов╕ редактори. Друку╓те в командному рядку  <TT>emacs</TT>  ╕
запуска╓те автоматичний пошук ╕ зам╕ну, ╕ вже через 2 хвилини можете
в╕днести в╕ддрукований зв╕т в штаб округу.

<P>
Складн╕ше, якщо ви працю╓те не в в╕йськов╕й комендатур╕. Помилки в цих
випадках бувають б╕льш р╕зноман╕тними, ╕ вам треба прикласти значн╕
зусилля щоб ╖х виправити. Скаж╕мо таке: вс╕ назви м╕сяц╕в в текст╕
повинн╕ бути написан╕ не скороченими, а вони написан╕ як завгодно - ╕
"С╕чень", ╕ "С╕ч.", ╕ нав╕ть "С╕ч". Почнете зм╕нювати вс╕ "С╕ч" на
"С╕чень" ╕ "С╕чень" п╕сля тако╖ операц╕╖ перетвориться у вас на
"С╕ченьень". Як бути? Тут прийдуть на пом╕ч регулярн╕ вирази. В нашому
випадку потр╕бно зам╕нити на "С╕чень" вс╕ випадки слова "С╕ч", в якому
п╕сля "ч" ╕де або пропуск " ", або крапка ".", ╕ ╕гнорувати випадки
коли п╕сля "ч" ╕де "е". Оце ╕ ╓ зразок регулярного виразу. (До реч╕,
дуже простого регулярного виразу. Реальне життя приносить задач╕
набагато складн╕ш╕, н╕ж ця.)

<P>
Тим, хто хоч раз працював з командним рядком (будь-де чи то в ДОС╕, чи
у Юн╕кс╕), регулярн╕ вирази знайом╕. П╕дстановка з╕рочки (*) та знаку
запитання (?) ╓ зразком найпрост╕ших регулярних вираз╕в. В командн╕й
оболонц╕ Юн╕кса (практично в будь-як╕й з них) з╕рочка означа╓
"будь-яка посл╕довн╕сть будь-яких символ╕в", а знак запитання означа╓
один будь-який символ. Тому, якщо вам, наприклад, потр╕бно д╕знатися
назви вс╕х файл╕в, що починаються на "l", ви можете дуже просто
надрукувати:  <TT>ls l*</TT> 

<P>
Теж саме стосу╓ться ╕ зак╕нчень файл╕в. Щоб д╕знатися, як╕ файли
зак╕нчуються на "z":  <TT>ls *z</TT>  (з одн╕╓ю в╕дчутною р╕зницею м╕ж ДОСом та
Юн╕ксом: останн╕й приклад в ДОС╕ не працю╓. В ДОС╕ з╕рочка означа╓
фактично "будь-яка посл╕довн╕сть л╕тер в╕д цього м╕сця до к╕нця
рядка"). 

<P>
Тож, зверн╕мося тепер до найпрост╕ших регулярних вираз╕в  у Перл╕. 

<H3><A NAME="section-1.4.2">Прост╕ (дуже прост╕) регулярн╕ вирази</A></H3>

<P>
Под╕бно до з╕рочки та знаку запитання в командн╕й оболонц╕, в Перл╕ ╓
так╕ ж вирази для визначення "будь-якого одного символа" та "будь-яко╖
посл╕довност╕ символ╕в". Але в Перл╕ це робиться ╕накше - будь-який
символ познача╓ться крапкою ".", а п╕сля крапки ставиться так-би
мовити "множник". В найпрост╕шому випадку таким множником ╓ таж сама
з╕рочка, що ╕ в командн╕й оболонц╕, ╕ тут вона означа╓ те ж саме -
"будь-яка к╕льк╕сть". Тобто, сказане в цьому абзац╕ означа╓, що ".*"
визнача╓ будь-яку посл╕довн╕сть будь-яких л╕тер.

<P>
Перш, н╕ж ╕ти дал╕ давайте розберемося як користуватися регулярними
виразами в Перл╕. 

<P>
Можуть бути р╕зн╕ застосування для них, але, мабуть, два основних це
так╕: по-перше, ви захочете д╕знатися чи входить той чи ╕нший рядок, який
опису╓ться регулярним виразом у текст (програма ма╓ крикнути:
"Знайшов!", коли натрапить на такий вираз) ╕, по-друге, знайшовши
вираз, ви схочете зам╕нити його на щось таке, що вам б╕льше до
вподоби. 

<P>
Наступний шматок коду демонстру╓ наше перше застосування регулярних
вираз╕в:

<PRE>
        #!/usr/bin/perl
        #### A.
        $a = "anyky ";  
        if ($a =~ m/a.*/) { print $a; }
        #### B.
        $b = "benyky ";
        if ($b =~ m/a.*/) { print $b; }
        #### C.
        $c ="iily varenyky ";
        if ($c =~ m/a.*/) { print $c; }
</PRE>

<P>
А результат його виконання такий:

<PRE>
        dk@sophy $ ./mytest.pl
        anyky iily varenyky dk@sophy $ 
</PRE>

<P>
Давайте спробу╓мо роз╕братися з анатом╕╓ю цього коду. Анатом╕я - це,
як в╕домо, копання у внутрощах. Давайте ╕ ми спробу╓мо роз╕брати один
╕з регулярних вираз╕в ╕ в╕дд╕лити в ньому мухи окремо, а котлети
окремо. Для конкретност╕ будемо розглядати один з трьох вираз╕в, а
саме той, що йде на початку:

<PRE>
        if ($a =~ m/a.*/) { print $a; }
</PRE>

<HR>
 <STRONG> META </STRONG>  Наступне можна прибрати, якщо перед цим написати розд╕л про умовн╕ оператори
<HR>

<P>
Тим, хто знайомий з програмуванням, безперечно здасться знайомою форма
 <TT>if (...) {...}</TT> , але ж наша книжка для непрограм╕ст╕в. Тому невеличке
пояснення: if разом з двома групами дужок - круглими та ф╕гурними
становить одну форму. Ця форма носить назву умовного оператора, ╕ з
назви ╖╖ повинно бути зрозум╕лим, що, перш, н╕ж виконувати якусь д╕ю,
умовний оператор перев╕ря╓ певну умову - чи треба цю д╕ю виконувати
взагал╕, чи можна ╖╖ спок╕йно про╕╜норувати. В нашому приклад╕ ми
користу╓мося найпрост╕шою формою умовного оператора. Ця форма ма╓
такий вигляд:

<PRE>
       if ( <умова> ) { <блок> }
</PRE>

<P>
Якщо умова записана в круглих дужках справедлива, то тод╕ викону╓ться
блок оператор╕в, записаний у ф╕гурних дужках п╕сля цього. Блок, який
запису╓ться у ф╕╜урних дужках п╕сля умови часто називають т╕лом
умовного оператора. 

<HR>
<HR>

<P>
Умовою виконання блоку ╓ справедлив╕сть чи несправедлив╕сть операц╕╖
над регулярним виразом в круглих дужках. Якщо операц╕я да╓ в
результат╕ "╕стину", то викону╓ться "<блок>" ( в нашому випадку
оператор 'print'). Якщо ж в результат╕ ╕стина не виходить, то ╕
'print' не викону╓ться.

<P>
Операц╕я, яка зд╕йсню╓ться над регулярним виразом, в свою чергу
склада╓ться з трьох частин. Ц╕ частини так╕ (розгляда╓мо випадок A.):

<PRE>
        л╕ва частина - "$a", 
        середня частина - "=~",
        права частина - "m/a.*/".
</PRE>

<P>
Середня частина в цьому вираз╕ ╓ оператором, який з'╓дну╓ скалярний
вираз, вказаний в л╕в╕й частин╕ з операц╕╓ю над регулярним виразом,
вказаним в прав╕й частин╕. 

<P>
Саме права частина виразу ╕ ╓ одним з тих регулярних вираз╕в, про як╕
ми зараз говоримо. Але сам регулярний вираз ╓ т╕льки частиною ц╕╓╖
третьо╖ (право╖) частини. В нашому конкретному випадку регулярним
виразом ╓ "a.*". ╤ означа╓ цей вираз: "л╕тера a, п╕сля яко╖ йде
будь-яка к╕льк╕сть будь-яких л╕тер".

<P>
Операц╕я над регулярним виразом познача╓ться л╕терою "m" та двома
"н╕бито-дужками", в як╕ заключено регулярний вираз. Тобто:

<PRE>
        "<операц╕я>/<регулярний-вираз>/". 
</PRE>

<P>
Л╕тера "m" познача╓ операц╕ю пошуку (або пор╕вняння) в регулярному
вираз╕. Походить ця л╕тера в╕д слова "match". Перл, побачивши такий
вираз проводить пор╕вняння зразку тексту (який сто╖ть л╕воруч в╕д
оператора "~=") ╕з регулярним виразом, який сто╖ть праворуч в╕д
оператора. Якщо знайдена в╕дпов╕дн╕сть, то Перл кричить (ненашою
мовою): "Match!" ╕ швиденько кида╓ться друкувати те, що ╕де у ф╕╜урних
дужках.

<P>
Якщо спробувати оце "match" виразити укра╖нською, то найб╕льше п╕д╕йде
слово: "Знайшов!". Саме оце "знайшов" виража╓ тут результат
"╕стина". Протилежний до нього результат виража╓ться в укра╖нськ╕й як:
"Та не переживай ти! Всяке бува╓!". А коли "всяке бува╓", оператор
'print' не викону╓ться.

<P>
Поглянувши пильн╕ше на результат виконання скрипту з регулярними
виразами, пом╕тите, що виконалися два блоки цього скрипту, а саме:
блок A. та блок C. Дв╕ зм╕нн╕ $a та $c мають в соб╕ л╕теру "a". У
зм╕нн╕й $b ╖╖ нема╓, тому ╕ оператор print не виконувався в цьому
блоц╕. 

<H3><A NAME="section-1.4.3">Деяк╕ спрощення в простих регулярних виразах</A></H3>

<P>
Перл широко в╕домий серед програм╕ст╕в сво╖ми скороченнями та
спрощеннями. Один ╕ той же регулярний вираз в Перл╕ можливо записати
багатьма р╕зними способами (кожен наступний з них коротший в╕д
попереднього). ╤нколи така лакон╕чн╕сть приводить до спрощення
написання програми у Перл╕, ╕нколи - навпаки, але практично завжди це
приводить до того, що програму в Перл╕ неможливо прочитати.

<P>
В цьому п╕дрозд╕л╕ ми спробу╓мо скоротити ╕ так короткий скрипт, який
використовувався в попередньому п╕дрозд╕л╕ (звичайно ж намагаючись
робити так, щоб в╕н все-таки продовжував працювати).

<H5><A NAME="section-1.4.3.1.1">Оператор m//</A></H5>

<P>
Таку надзвичайно складну штуку, як одна л╕тера, в Перл╕ можна зам╕нити
прост╕шою штукою - н╕чим. Два таких вирази тотожн╕ в Перл╕:  <TT>m/a.*/</TT>  та
 <TT>/a.*/</TT> . А якщо два вирази тотожн╕, то зрозум╕ло, що кожна нормальна
людина з двох вираз╕в, як╕ приводять до одного й того ж результату,
вибере той вираз, який коротший. ╤ це ╓ причиною того, що в б╕льшост╕
скрипт╕в ви будете бачити " <I>" ╕ не побачите "m</I> ". 

<P>
З урахуванням цього наш скрипт перетворю╓ться на ось таке:

<PRE>
        #!/usr/bin/perl
        $a = "anyky ";
        if ($a =~ /a.*/) { print $a; }
        $b = "benyky ";
        if ($b =~ /a.*/) { print $b; }
        $c ="iily varenyky ";
        if ($c =~ /a.*/) { print $c; }
</PRE>

<P>
Прост╕ше? Так. Але не набагато. Йдемо дал╕...

<H5><A NAME="section-1.4.3.1.2">Дужки, що оточують регулярний вираз</A></H5>

<P>
╤нколи бува╓ не дуже зручно користуватися стандартними "дужками", в
як╕ береться регулярний вираз - "//". Наприклад, якщо ви робите пошук
в текст╕ блок╕в ╕з косими всередин╕. Для того, щоб ╕золювати ц╕ кос╕
в╕д механ╕зму пошуку ╕снують р╕зн╕ засоби. Але коли таких "╕золятор╕в"
занадто багато, бува╓ так, що регулярний вираз перетворю╓ться на щось
таке, що прочитати неможливо. ╤ у таких випадках було б непагано мати
щось на зам╕ну для стандартних дужок. 

<P>
Такою зам╕ною ╓ ... практично будь що. Але т╕льки в тому випадку, коли
використову╓ться форма m// (л╕тера m перед дужками
обов'язкова). Зам╕ною для // може бути будь-який не алфав╕тно-цифровий
╕ не нульовий символ. Вс╕ наступн╕ вирази будуть тотожними:

<PRE>
        if ($a =~ m/a.*/) { print $a; }
        if ($a =~ m:a.*:) { print $a; }
        if ($a =~ m~a.*~) { print $a; }
</PRE>

<P>
Кр╕м цього ма╓ться ще один вар╕ант запису цього ж самого виразу, в
якому використовуються ф╕╜урн╕ дужки:

<PRE>
        if ($a =~ m{a.*}) { print $a; }
</PRE>

<H5><A NAME="section-1.4.3.1.3">Стандартна зм╕нна $_</A></H5>

<P>
В попередн╕х абзацах ми конкретно вказували з якою зм╕нною ведеться
пор╕вняння регулярного виразу. Але в дуже багатьох випадках ц╕
конкретн╕ зм╕нн╕ можна зам╕нити на одну спец╕ально передбачену для
цього зм╕нну, яка ╕ служить спец╕ально для того, щоб провадити р╕зн╕
операц╕╖ над текстовими даними ╕ регулярними виразами. Ця зм╕нна в
Перл╕ запису╓ться, як $_ ╕ вжива╓ться наступним чином.

<P>
Ц╕й зм╕нн╕й можна присвоювати будь-як╕ значення, так саме, як
будь-як╕й ╕нш╕й "нормальн╕й" зм╕нн╕й. Але, в багатьох випадках, коли
зм╕нна $_ використову╓ться в операц╕ях, на не╖ можна не вказувати
ссилку (тобто, прост╕ше кажучи ╖╖ можна не називати) ╕, кр╕м того, сам
знак операнду може опускатися так саме. 

<P>
З усим цим сказаним, наш попередн╕й приклад прийма╓ зовс╕м лакон╕чну
форму: 

<PRE>
        #!/usr/bin/perl
        $_ = "anyky ";
        if (/a.*/) { print }
        $_ ="benyky ";
        if (/a.*/) { print }
        $_="iily varenyky ";
        if (/a.*/) { print }
</PRE>

<P>
Розглянемо ближче в цьому приклад╕ два наступн╕ рядки:

<PRE>
        $_ = "anyky ";
        if (/a.*/) { print }
</PRE>

<P>
В першому рядку зм╕нн╕й $_ присвою╓ться якесь значення. З цим все
зрозум╕ло, ╕ питань тут нема╓. Трохи складн╕ше з другим рядком. У
ф╕╜урних дужках сто╖ть просто 'print'. Саме час запитати: "Print -
що?". ╤ справд╕ - що? 

<P>
Оператор print, п╕дпада╓ п╕д туж саму конвенц╕ю, що ╕ б╕льш╕сть
оператор╕в Перла. А саме: якщо в╕н не знаходить явно вказаних даних,
над якими в╕н повинен працювати (друкувати - у випадку з print), в╕н
друку╓ стандартну зм╕нну $_.

<P>
Теж саме стосу╓ться ╕ л╕во╖ частиною виразу - коли в круглих дужках
вказаний сам т╕льки регулярний вираз ╕ не вказано текстово╖ зм╕нно╖,
цей регулярний вираз пор╕вню╓ться ╕з стандартною зм╕нною $_. 

<P>
Якщо виразити те, що написане в рядку  <TT>if (/a.*/) { print }</TT>  ╕
перекласти це з мови Перл на мову людську то вийде таке: "Якщо
стандартна текстова зм╕нна  <TT>$_</TT>  м╕стить в соб╕ л╕теру  <TT>a</TT>  п╕сля яко╖ йде
будь-що, то треба цю стандартну зм╕нну надрукувати". 

<H5><A NAME="section-1.4.3.1.4">"Несправедлив╕" регулярн╕ вирази</A></H5>

<P>
Що робити, якщо нам навпаки потр╕бно вибрати текстов╕ рядки, в яких не
зустр╕ча╓ться той чи ╕нший регулярний вираз? Чи потр╕бно для цього
писати якийсь спец╕льний вираз, чи може користуватися ╕ншою формою
умовного оператора  <TT>if</TT> ? Чи ще що-небудь? 

<P>
Можна користуватися будь-яким з названих метод╕в. Але спец╕ально для
таких ситуац╕й ╕сну╓ ╕нша форма пор╕вняння. Зам╕сть  <TT>=~</TT>  потр╕бно
користуватися оператором  <TT>!~</TT> , ╕ ал╜оритм роботи команди при цьому
зм╕ню╓ться на прямо протилежний: блок, що йде в т╕л╕ умовного
оператора викону╓ться т╕льки тод╕, коли не викону╓ться д╕я над
регулярним виразом.

<P>
Тобто:

<PRE>
        #!/usr/bin/perl
        $a = "anyky ";
        if ($a !~ /a.*/) { print $a; }
        $b = "benyky ";
        if ($b !~ /a.*/) { print $b; }
        $c ="iily varenyky ";
        if ($c !~ /a.*/) { print $c; }
</PRE>

<P>
да╓ такий результат:

<PRE>
         ./mytest.pl
         benyky 
</PRE>

<P>
Знак оклику всередин╕ круглих дужок оператора  <TT>if</TT>  також зм╕ню╓
значення умовного оператора на протилежне. Тобто, т╕льки що приведений
скрипт буде анало╜╕чним до наступного:

<PRE>
        #!/usr/bin/perl
        $_ = "anyky ";
        if (!/a.*/) { print }
        $_ ="benyky ";
        if (!/a.*/) { print }
        $_="iily varenyky ";
        if (!/a.*/) { print }
</PRE>

<P>
╤ нарешт╕ - ще одна форма умовного оператора. Наск╕льки мен╕ в╕домо -
Перл - це ╓дина мова, яка в даний момент ма╓ таку форму умовного
оператора. В Перл╕ оператор  <TT>unless</TT>  ╓ зворотн╕м до оператора
 <TT>if</TT> . Тобто,  <TT>if (!<умова>) {<д╕я>}</TT>  ╓ анало╜╕чним до 
 <TT>unless (<умова>) {<д╕я>}</TT> , ╕ з урахуванням т╕льки що сказаного попередн╕й
скрипт можна переписати у вигляд╕:

<PRE>
        #!/usr/bin/perl
        $_ = "anyky ";
        unless (/a.*/) { print }
        $_ ="benyky ";
        unless (/a.*/) { print }
        $_="iily varenyky ";
        unless (/a.*/) { print }
</PRE>


<H3><A NAME="section-1.4.4">Формальне представлення регулярних вираз╕в</A></H3>

<P>
Що-ж, п╕сля того, як ми вже трохи познайомилися ╕ ╕з самими
регулярними виразами, ╕ ╕з деякими ╖х застосуваннями, мабуть час вже
просто витягти руки з кишень, простягнути ╖х один одному ╕ формально
представитися ╕ роззнайомитися ближче з подробицями. Але ж, звичайно,
п╕д час таких формальних знайомств про себе багато не кажуть. Т╕льки й
того що, такий-то такий-то, працюю там-то, а роблю... Та ладно, чого
там!

<P>
Тож, наше оф╕ц╕йне знайомство з регулярними виразами теж буде не
занадто фам╕льярним. Досить коротк╕ в╕домост╕ про синтаксис, к╕лька
коротеньких приклад╕в, тощо. Тож, будьмо!

<H5><A NAME="section-1.4.4.1.1">Знаходження початку та к╕нця</A></H5>
  <I>╢ т╕льки дв╕ неск╕нченн╕ реч╕, що я знаю. Перша -<br></I> 
  <I> це дур╕сть, ╕ друга - це Всесв╕т. </I> <br>
  <I> Щоправда я не впевнений щодо другого </I> <br>
<PRE>
                       <I> А. Ейнштейн </I> <br>
</PRE>



<PRE>
        ^ - означа╓ початок рядка, якщо сто╖ть на початку регулярного
            виразу. ╤нше застосування ми розглянемо п╕зн╕ше.

        $ - означа╓ к╕нець рядка (звичайно ж, анало╜╕чно до
            попереднього випадку, т╕льки якщо сто╖ть в к╕нц╕
            регулярного виразу).
</PRE>

<P>
Як об╕цяно, к╕лька коротеньких приклад╕в. 

<P>
  <STRONG>Приклад 1. </STRONG> 


<PRE>
            $_="anyky";
            if (/^a.*/) { print }
            $_ ="benyky ";
            if (/^a.*/) { print }
            $_=" varenyky";
            if (/^a.*/) { print }
</PRE>
            
<P>
да╓ в результат╕:

<PRE>
            ./mytest.pl
            anyky
</PRE>

<P>
Зрозум╕ло, бо т╕льки в першому вираз╕  <TT>a</TT>  сто╖ть на початку рядка. 

<P>
  <STRONG>Приклад 2. </STRONG> 


<P>
А в такому вар╕ант╕

<PRE>
            $_="anyky";
            if (/.*y$/) { print }
            $_ ="benyky ";
            if (/.*y$/) { print }
            $_=" varenyky";
            if (/.*y$/) { print }
</PRE>

<P>
ми отриму╓мо таке:

<PRE>
            ./mytest.pl
            anyky varenyky          
</PRE>

<P>
(Зверн╕ть увагу на пропуск, що ╕де в к╕нц╕ другого виразу, ╕ стане
зрозум╕ло, чому не надруковано другий вираз.)

<P>
  <STRONG>Приклад 3. </STRONG> 


<P>
Якщо об'╓днати початок рядка та к╕нець рядка, то отрима╓мо таке:

<PRE>
            $_="anyky";
            if (/^a.*y$/) { print }
            $_ ="benyky ";
            if (/^a.*y$/) { print }
            $_=" varenyky";
            if (/^a.*y$/) { print }

            ./mytest.pl
            anyky
</PRE>


<P>
  <STRONG>Приклад 4. </STRONG> 


<P>
Як знайти пустий рядок? Дуже просто! Пустий рядок склада╓ться з
початку ╕ к╕нця, ╕ н╕чого посередин╕:

<PRE>
            $_="";
            if (/^$/) { print "Пустий рядок!" }

            ./mytest.pl
            Пустий рядок!
</PRE>

<P>
╤ невеличка вправа п╕д к╕нець:

<P>
  <STRONG> Вправа </STRONG> 


<P>
Попробуйте наперед сказати, що надрукують так╕ оператори?

<PRE>
            $_="слово";
            if (/^.*$/) { print "Рядок не пустий!" }
            $_="";
            if (/^.*$/) { print "Рядок не пустий!" }
</PRE>

<P>
Напиш╕ть невеличкий скрипт з цим оператором ╕ перев╕рте, чи в╕рне було
ваше передбачення.

<OL>
  <LI> Поясн╕ть чому оператор надрукував, те що в╕н надрукував, або
   поясн╕ть чому в╕н цього не надрукував?

  <LI> Якщо ваше передбачення було не в╕рним, спробуйте зм╕нити скрипт
   так, щоб в╕н друкував те, що потр╕бно. 


</OL>
<H5><A NAME="section-1.4.4.1.2">Докладн╕ше про множення та множники</A></H5>

<P>
Регулярн╕ вирази в Перл╕ мають певну к╕льк╕сть символ╕в, як╕ мають
дещо спец╕альне трактування. Ми вже знайом╕ з к╕лькома з них, це
крапка, з╕рочка, стр╕лка вгору ( <TT>^</TT> ) та знак долара ( <TT>$</TT> ). ╢ ще деяк╕
спец╕альн╕ символи кр╕м цих, але ╖х не дуже багато. За виключенням
цього досить невеликого набору символ╕в, вс╕ ╕нш╕ трактуються в Перл╕
досить просто - вони означають сам╕ себе. Так, як, наприклад, л╕тера
 <TT>a</TT> , у вираз╕  <TT>if (^a) </TT>  означа╓ саме це - л╕теру  <TT>a</TT> . 

<P>
Тобто, б╕льш╕сть алфав╕тно-цифрових символ╕в у регулярних виразах
Перла не мають якогось особливого значення ╕  <STRONG>перше правило</STRONG>  буде
таке:

<PRE>
       будь-який символ за      - означа╓ сам цей символ.
       виключенням спец╕альних 
       символ╕в     
</PRE>

<P>
Але дал╕ якраз ╕ почина╓ться розмова про множники. Вони потр╕бн╕, коли
треба в╕дшукати рядки, в яких та чи ╕нша л╕тера трапля╓ться не один
раз (як в  <TT> if (/a/) </TT> ), або два рази ( як в  <TT> if (/aa/) </TT> ), а певну
(наперед задану або, нав╕ть, ╕ нев╕дому наперед) к╕льк╕сть раз╕в.  

<P>
До цього моменту ми користувалися ╓диним модиф╕катором (множником)
коли треба було в╕дшукати дов╕льну к╕льк╕сть л╕тер у вираз╕. Це була
комб╕нац╕я ╕з крапки та з╕рочки " <TT>.*</TT> ". Трапляються ╕ ╕нш╕ ситуац╕╖
- треба знайти рядки, в яких л╕тера "зю" зуст╕ча╓ться 5 (не б╕льше, ╕
не менше) раз╕в, або коли в╕дм╕тити т╕ речення, в яких сто╖ть по три
коми п╕дряд (Нав╕ть ╕ дв╕ п╕дряд буде вже багато, тому може виникнути
задача в╕дшукати вс╕ м╕сця, де сто╖ть б╕льше одн╕╓╖ коми, ╕ зм╕нити ╖х
... ну, скаж╕мо на знак запитання). Саме в таких випадках потр╕бно
вдаватися до "множник╕в" -- множаться л╕тери на рази. Вс╕ наступн╕
вирази вживаються, коли потр╕бно в╕дшукати (по-перл╕вськи кажучи
"match") певний символ, який трапля╓ться певну к╕льк╕сть раз╕в. ╤ вс╕
ц╕ вирази вживаються так:

<PRE>
         <символ><множник>
</PRE>
         
<P>
Де в якост╕ множник╕в вживаються так╕ реч╕ (в наступних
визначеннях  <TT>N</TT>  ╕  <TT>M</TT>  - це ц╕л╕ числа):

<PRE>
       "*"            - вже в╕дома нам з╕рочка, яка буквально означа╓
                      "будь-яка к╕льк╕сть раз╕в" (включаючи нуль);

       +            - дуже схожий за вжитком до з╕рочки *, але якщо
                      з╕рочка означа╓ "будь-яку к╕льк╕сть раз╕в", то
                       <TT>+</TT>  означа╓ "один, або б╕льше раз╕в";

       {N}          - означа╓ "N раз╕в".

       {N,M}        - означа╓ "в╕д N до M раз╕в".
</PRE>
                      

<PRE>
       {N,}         -  означа╓ "N або б╕льше раз╕в".

       {,M}         - означа╓ "не б╕льше, н╕ж M раз╕в".
</PRE>

<P>
  <STRONG>N.B. </STRONG> 

<PRE>
        Зауважте, що п╕д к╕льк╕стю раз╕в в ус╕х перечислених
        випадках ма╓ться на уваз╕ к╕льк╕сть раз╕в ск╕льки та чи ╕нша
        л╕тера сто╖ть  <I>п╕дряд</I>  в текстовому рядку, а не загальна
        к╕льк╕сть л╕тер в рядку. 
</PRE>

<P>
╤ зразу-ж не в╕дкладаючи на завтра приклади:

<P>
  <STRONG> Приклад 1 </STRONG> 


<P>
Вираз  <TT> /b+/ </TT>  буде в╕дпов╕дати таким текстовим фра╜ментам:

<UL>
  <LI> banana
  <LI> abooboo
  <LI> abba

</UL>
<P>
, але не буде в╕дпов╕дати такому як     

<UL>
  <LI> led zeppelin

</UL>
<P>
  <STRONG> Приклад 2 </STRONG>  

<P>
Вираз  <TT> /b*/ </TT>  в╕дпов╕да╓ вс╕м виразам з попереднього прикладу. 

<P>
  <STRONG> Приклад 3 </STRONG> 


<P>
  <TT> /o{2}/ </TT>  в╕дпов╕да╓ т╕льки одному ╓диному виразу: "abooboo", а 
  <TT> /b{2}/ </TT>  в╕дпов╕да╓ т╕льки "abba".

<P>
  <STRONG> Приклад 4 </STRONG> 


<P>
 Регулярний вираз  <TT> /a+/ </TT>  ╓ тотожним таким регулярним виразам, як
  <TT> /a{1,}/ </TT>  та  <TT> /aa*/ </TT> . 



<P>
   <STRONG>Друге правило </STRONG>  формулю╓ться таким чином: все, що сто╖ть в
квадратних дужках, розгляда╓ться Перлом як виб╕р. - п╕дходить
будь-який символ ╕з тих, що вказан╕ в цьому перел╕ку. Тобто,  <TT> [ab] </TT>  означа╓ "або  <TT>a</TT> , або  <TT>b</TT> ".

<P>
Людин╕, як╕й потр╕бно в╕дшукати в текст╕ схож╕ слова, як наприклад,
"трава" та "дрова" потр╕бно було-б написати таке:

<PRE>
        if (/[тд]р[оа]ва/) { print }
</PRE>

<P>
(Але зверн╕ть увагу, що п╕д цю категор╕ю п╕дпадають також так╕
вар╕анти, як "драва" та "трова".

<P>
  <STRONG> Приклад 5 </STRONG> 


<P>
Якщо Вам потр╕бно ╕з списку дат, надрукувати т╕льки т╕, що
в╕дносяться або до 1998 або до 1999 року, Ви можете написати таке:

<P>
    if (/199[89]/) { print }

<P>
Деяким розширенням до цього правила ╓ введення спец╕альних символ╕в
усередин╕ квадратних дужок. Щоб не переписувати весь п╕дряд алфав╕т,
коли Вам просто потр╕бно сказати "Будь-яка л╕тера", Ви просто можете
записати, так, як би вираз "В╕д а до я" Вам треба було б записати на
шматку паперу: "а-я". Виглядатиме це дуже просто: 

<PRE>
        if (/a-z/) { print }
</PRE>

<P>
Що просто означа╓, що буде надрукаваний кожен рядок, в якому
трапля╓ться будь-яка л╕тера (маленька !) англ╕йсько╖ абетки. Тобто:

<P>
  <STRONG> Приклад 6 </STRONG> 


<P>
 Вищенаведений регулярний вираз в╕дпов╕да╓ таким текстовим рядкам:

<UL>
  <LI> Abudabi
  <LI> 10 indians
  <LI> potato head

</UL>
<P>
╕ не буде в╕дпов╕дати жодному з наведених нижче:

<UL>
  <LI> 505-444-124
  <LI> $20.77
  <LI> ALFA TEAM

</UL>
<P>
Теж саме стосу╓ться ╕ цифр: будь-яка десяткова цифра, що прийма╓
значення в╕д 3 до 8 може бути записана як  <TT> [3-7] </TT> .

<P>
╤ вже, фактично, в багатьох наведених прикладах ми сформулювали 
 <STRONG> трет╓ правило </STRONG> : прост╕ш╕ регулярн╕ вирази комб╕нуються ╕
утворюють б╕льш складн╕ вирази. 

<P>
  <STRONG> Приклад 7 </STRONG> 


<P>
Регулярний вираз  <TT> /^ 199[7-9] [a-z]+/ </TT>  склада╓ться фактично з п'яти
"атомарних" регулярних вираз╕в:

<UL>
  <LI> ^ - початок рядка;
  <LI> " " - пропуск;
  <LI> 199[7-9] - 1997, 1998 або 1999;
  <LI> " " - ще один пропуск;
  <LI> [a-z]+ - слово, яке склада╓ться з будь-яко╖ (ненульово╖) к╕лькост╕
  латинських л╕тер.

</UL>
<P>
Наступн╕ рядки вс╕ будуть в╕дпв╕дати цьому регулярному виразу: 

<PRE>
      +-------------------------
      | 1998 omega
      | 1999 alpha
      | 1997 beta
      | 1997 gamma $20
      | 1998 sigma Proxima
      | 1999 s $40
      | 
</PRE>

<P>
, а наступн╕ - не п╕дходять п╕д це визначення:

<PRE>
      +-------------------------
      |1999 omega
      |1998alpha
      |1997 Beta
      |1999 $100
      |  1999 omega
      |
</PRE>

<P>
Невеличк╕ вправи, що виплива╓ з цього прикладу: 

<OL>
  <LI> Що якщо у Вас п╕сля номеру року йде не один пропуск, а може йти
    к╕лька? Як у цьому випадку зм╕ниться регулярний вираз? (Але пропуск
    повинен бути присутн╕й)

  <LI> Як зм╕нити вираз так, щоб в╕н друкував т╕льки т╕ рядки, в яких ╓
    т╕льки одне слово ╕ не б╕льше?

</OL>
<H5><A NAME="section-1.4.4.1.3">Застосування результат╕в регулярних вираз╕в</A></H5>

<P>
До цього ми мали т╕льки одне застосування регулярних вираз╕в, а саме -
надрукувати рядок, якщо регулярний вираз справдився. Але, саме собою
зрозум╕ле, що цього може виявитися занадто мало. Дуже часто потр╕бно
бува╓ виконати як╕сь д╕╖ саме над т╕╓ю частиною рядка, яка задовольня╓
певному регулярному виразу.

<P>
В цьому випадку на допомогу приходять дужки. Застосування круглих
дужок да╓ можлив╕сть ╕з ц╕лого регулярного виразу вид╕лити певну його
частину, яка присвою╓ться п╕сля перев╕рки спец╕альн╕й зм╕нн╕й. Над
ц╕╓ю зм╕нною можна п╕зн╕ше виконувати будь-як╕ д╕╖, дозволен╕ над
зм╕нними. Так╕ зм╕нн╕ мають спец╕альний вигляд ╕ позначаються одним ╕з
двох способ╕в: або зворотньою косою, за якою ╕де цифра в╕д 1 до 9
(наприклад, \1, \5), або знаком долара за яким ╕де натуральне число
(як наприклад, $1, $5 або $29). Кожна така зм╕нна ($n або \n) означа╓
ту частину рядка, що поставлена у в╕дпов╕дн╕сть регулярному виразу,
який записаний у n-х зл╕ва дужках. 

<P>
 <STRONG> Приклад 1 </STRONG> 


<P>
В╕зьмемо регулярний вираз ╕з попереднього параграфу ╕ трохи його
зм╕нимо. Нехай деяка зм╕нна прийма╓ по черз╕ так╕ значення:

<PRE>
           $a =   " 1998 omega";
           $a =   " 1999 alpha";
           $a =   " 1997 beta"
           $a =   " 1997 gamma $20"
           $a =   " 1998 sigma Proxima";
           $a =   " 1999 s $40";
           $a =   " 1999 omega";
           $a =   " 1998alpha";
           $a =   " 1997 Beta";
           $a =   " 1999 $100";
           $a =   "   1999 omega";
</PRE>

<P>
До всих цих зм╕нних ми застосу╓мо такий оператор: 

<PRE>
          if ($a =~ /^ (199[7-9]) ([a-z]+)/) {
             $year = $1;
             $item = $2;
             print "Р╕к: ", $year," пункт: ", $item, "\n";
          }
</PRE>

<P>
Тод╕ результатом роботи цього скрипту буде такий вих╕д:

<PRE>
         Р╕к: 1998 пункт: omega
         Р╕к: 1999 пункт: alpha
         Р╕к: 1997 пункт: beta
         Р╕к: 1997 пункт: gamma
         Р╕к: 1998 пункт: sigma
         Р╕к: 1999 пункт: s
</PRE>

<P>
 <STRONG> Приклад 2 </STRONG> 


<P>
Перша робоча програмка, яка може хоч на що-небудь згодитись. Давайте
спробу╓мо написати скрипт, який буде працювати з реальними даними в
будь-якому Юн╕кс╕. Увага! Це Юн╕кс специф╕чний скрипт, ╕ в╕н не ма╓ аж
н╕якого сенсу у ╕нших системах типу В╕ндовс, ДОС, тощо. "Юн╕кс" тут
використову╓ться у "широкому" смисл╕ - Л╕накс теж попада╓ п╕д це
означення. 

<P>
З часом, осво╖вши Перл трохи б╕льше, Ви пом╕тите, що цей же скрипт
можна написати набагато прост╕ше. Але ми напишемо його, використовуючи
т╕льки т╕ засоби, що ми вже вивчили до цього моменту. Тому в ньому
можлив╕ деяк╕ "важк╕" конструкц╕╖. 

<P>
Але нам все-ж таки не об╕йтись в╕д к╕лькох нових речей. Це реч╕ так╕: 


<P>
Наш скрипт буде такий:

<PRE>
          #!/usr/bin/perl
          if (open (STDIN, "who|")) {
              while (<>) {
                if (/^([a-z][a-z0-9]*) /) {
                    print $1, "\n"
                }
              }
          } else {
              die "Не можу створити процес who !\n";
          }
</PRE>


<P>
Уяв╕ть соб╕, що Вам потр╕бно знати, хто працю╓ на даний момент у Ваш╕й
систем╕. У Юн╕кс╕ про це можна д╕знатися, виконавши команду 
 <TT> who </TT> . 
<HR>
<HR>
<HR>


<PRE>
     <STRONG> META </STRONG>  ((( non greedy вирази з  -- ? ))) 

     <STRONG> META </STRONG>  ((( дужки ╕ $<цифра> )))
       * scope of $(digit)
       * difference \<digit> $<digit> (more: \11, $11, \011)
       * othe matches $+, $&, $`, $', $0

     <STRONG> META </STRONG>  ((( приклад бази даних - телефонний дов╕дник )))
    ====
     <STRONG> META </STRONG>  : (спец╕альн╕ символи (metacharacters) - egrep )

           \   Quote the next metacharacter
           ^   Match the beginning of the line
           .   Match any character (except newline)
           $   Match the end of the line (or before newline at the end)
           |   Alternation
           ()  Grouping
           []  Character class

     <STRONG> META </STRONG>  :  (спец╕альн╕ символи - розширення до egrep )
</PRE>


<PRE>
           \t          tab                   (HT, TAB)
           \n          newline               (LF, NL)
           \r          return                (CR)
           \f          form feed             (FF)
           \a          alarm (bell)          (BEL)
           \e          escape (think troff)  (ESC)
           \033        octal char (think of a PDP-11)
           \x1B        hex char
           \c[         control char
           \l          lowercase next char (think vi)
           \u          uppercase next char (think vi)
           \L          lowercase till \E (think vi)
           \U          uppercase till \E (think vi)
           \E          end case modification (think vi)
           \Q          quote (disable) pattern metacharacters till \E
</PRE>

    <hr noshade size=1>
    <address>
    Natalya and Dmytro Kovalev
    <br>Пиш╕ть нам за адресою:<A HREF="mailto:kov@tokyo.email.ne.jp ">  kov@tokyo.email.ne.jp</A><BR>
    Домашня стор╕нка: <A HREF="http://www.asahi-net.or.jp/~as9d-kvlv">http://www.asahi-net.or.jp/~as9d-kvlv </A>
    <br>Чтв С╕ч 27 12:29:36 JST 2000
    <hr noshade size=1></address>
    <center><a href="http://www.cybercount.com/cgi-bin/click.cgi">	    <img src="http://www.cybercount.com/cgi-bin/getimage.cgi">	    </a></center>Counter:  	    <IMG SRC="http://cybercount.com/cgi-bin/new/c?ID=dmytro&tr=yes&ref=perl"><br clear>
    </BODY>
    </HTML>
